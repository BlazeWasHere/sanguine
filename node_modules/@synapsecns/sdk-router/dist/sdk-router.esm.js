import invariant from 'tiny-invariant';
import { BigNumber } from '@ethersproject/bignumber';
import { AddressZero } from '@ethersproject/constants';
import { Interface } from '@ethersproject/abi';
import { Contract } from '@ethersproject/contracts';
import JSBI from 'jsbi';
import _Big from 'big.js';
import toFormat from 'toformat';
import _Decimal from 'decimal.js-light';
import { getAddress } from '@ethersproject/address';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var ETH_NATIVE_TOKEN_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
var handleNativeToken = function handleNativeToken(tokenAddr) {
  return tokenAddr === '' || tokenAddr === AddressZero ? ETH_NATIVE_TOKEN_ADDRESS : tokenAddr;
};

var abi = [
	{
		inputs: [
			{
				internalType: "address",
				name: "_synapseBridge",
				type: "address"
			}
		],
		stateMutability: "nonpayable",
		type: "constructor"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "previousOwner",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "OwnershipTransferred",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "address",
				name: "tokenIn",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amountIn",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "tokenOut",
				type: "address"
			},
			{
				internalType: "bytes",
				name: "rawParams",
				type: "bytes"
			}
		],
		name: "adapterSwap",
		outputs: [
			{
				internalType: "uint256",
				name: "amountOut",
				type: "uint256"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "string",
				name: "symbol",
				type: "string"
			},
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "enum LocalBridgeConfig.TokenType",
				name: "tokenType",
				type: "uint8"
			},
			{
				internalType: "address",
				name: "bridgeToken",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "bridgeFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "minFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxFee",
				type: "uint256"
			}
		],
		name: "addToken",
		outputs: [
			{
				internalType: "bool",
				name: "wasAdded",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "string",
						name: "id",
						type: "string"
					},
					{
						internalType: "address",
						name: "token",
						type: "address"
					},
					{
						internalType: "enum LocalBridgeConfig.TokenType",
						name: "tokenType",
						type: "uint8"
					},
					{
						internalType: "address",
						name: "bridgeToken",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "bridgeFee",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "minFee",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "maxFee",
						type: "uint256"
					}
				],
				internalType: "struct LocalBridgeConfig.BridgeTokenConfig[]",
				name: "tokens",
				type: "tuple[]"
			}
		],
		name: "addTokens",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "allPools",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "pool",
						type: "address"
					},
					{
						internalType: "address",
						name: "lpToken",
						type: "address"
					},
					{
						components: [
							{
								internalType: "bool",
								name: "isWeth",
								type: "bool"
							},
							{
								internalType: "address",
								name: "token",
								type: "address"
							}
						],
						internalType: "struct PoolToken[]",
						name: "tokens",
						type: "tuple[]"
					}
				],
				internalType: "struct Pool[]",
				name: "pools",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery",
				name: "originQuery",
				type: "tuple"
			},
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery",
				name: "destQuery",
				type: "tuple"
			}
		],
		name: "bridge",
		outputs: [
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "bridgeTokens",
		outputs: [
			{
				internalType: "address[]",
				name: "tokens",
				type: "address[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "bridgeTokensAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint256[]",
				name: "amounts",
				type: "uint256[]"
			}
		],
		name: "calculateAddLiquidity",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "calculateBridgeFee",
		outputs: [
			{
				internalType: "uint256",
				name: "feeAmount",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "calculateRemoveLiquidity",
		outputs: [
			{
				internalType: "uint256[]",
				name: "amountsOut",
				type: "uint256[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "dx",
				type: "uint256"
			}
		],
		name: "calculateSwap",
		outputs: [
			{
				internalType: "uint256",
				name: "amountOut",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "tokenAmount",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "tokenIndex",
				type: "uint8"
			}
		],
		name: "calculateWithdrawOneToken",
		outputs: [
			{
				internalType: "uint256",
				name: "amountOut",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "config",
		outputs: [
			{
				internalType: "enum LocalBridgeConfig.TokenType",
				name: "tokenType",
				type: "uint8"
			},
			{
				internalType: "address",
				name: "bridgeToken",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "fee",
		outputs: [
			{
				internalType: "uint40",
				name: "bridgeFee",
				type: "uint40"
			},
			{
				internalType: "uint104",
				name: "minFee",
				type: "uint104"
			},
			{
				internalType: "uint112",
				name: "maxFee",
				type: "uint112"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "tokenIn",
				type: "address"
			},
			{
				internalType: "address",
				name: "tokenOut",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amountIn",
				type: "uint256"
			}
		],
		name: "getAmountOut",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery",
				name: "",
				type: "tuple"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "tokenOut",
				type: "address"
			}
		],
		name: "getConnectedBridgeTokens",
		outputs: [
			{
				components: [
					{
						internalType: "string",
						name: "symbol",
						type: "string"
					},
					{
						internalType: "address",
						name: "token",
						type: "address"
					}
				],
				internalType: "struct BridgeToken[]",
				name: "tokens",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				components: [
					{
						internalType: "string",
						name: "symbol",
						type: "string"
					},
					{
						internalType: "uint256",
						name: "amountIn",
						type: "uint256"
					}
				],
				internalType: "struct DestRequest[]",
				name: "requests",
				type: "tuple[]"
			},
			{
				internalType: "address",
				name: "tokenOut",
				type: "address"
			}
		],
		name: "getDestinationAmountOut",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery[]",
				name: "destQueries",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "tokenIn",
				type: "address"
			},
			{
				internalType: "string[]",
				name: "tokenSymbols",
				type: "string[]"
			},
			{
				internalType: "uint256",
				name: "amountIn",
				type: "uint256"
			}
		],
		name: "getOriginAmountOut",
		outputs: [
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery[]",
				name: "originQueries",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "owner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			}
		],
		name: "poolInfo",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "pool",
				type: "address"
			}
		],
		name: "poolTokens",
		outputs: [
			{
				components: [
					{
						internalType: "bool",
						name: "isWeth",
						type: "bool"
					},
					{
						internalType: "address",
						name: "token",
						type: "address"
					}
				],
				internalType: "struct PoolToken[]",
				name: "tokens",
				type: "tuple[]"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "poolsAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			}
		],
		name: "removeToken",
		outputs: [
			{
				internalType: "bool",
				name: "wasRemoved",
				type: "bool"
			}
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address[]",
				name: "tokens",
				type: "address[]"
			}
		],
		name: "removeTokens",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "renounceOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "address",
				name: "spender",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "setAllowance",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract ISwapQuoter",
				name: "_swapQuoter",
				type: "address"
			}
		],
		name: "setSwapQuoter",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "enum LocalBridgeConfig.TokenType",
				name: "tokenType",
				type: "uint8"
			},
			{
				internalType: "address",
				name: "bridgeToken",
				type: "address"
			}
		],
		name: "setTokenConfig",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "bridgeFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "minFee",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "maxFee",
				type: "uint256"
			}
		],
		name: "setTokenFee",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "address",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				components: [
					{
						internalType: "address",
						name: "swapAdapter",
						type: "address"
					},
					{
						internalType: "address",
						name: "tokenOut",
						type: "address"
					},
					{
						internalType: "uint256",
						name: "minAmountOut",
						type: "uint256"
					},
					{
						internalType: "uint256",
						name: "deadline",
						type: "uint256"
					},
					{
						internalType: "bytes",
						name: "rawParams",
						type: "bytes"
					}
				],
				internalType: "struct SwapQuery",
				name: "query",
				type: "tuple"
			}
		],
		name: "swap",
		outputs: [
			{
				internalType: "uint256",
				name: "amountOut",
				type: "uint256"
			}
		],
		stateMutability: "payable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "swapQuoter",
		outputs: [
			{
				internalType: "contract ISwapQuoter",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		name: "symbolToToken",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "synapseBridge",
		outputs: [
			{
				internalType: "contract ISynapseBridge",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "tokenToSymbol",
		outputs: [
			{
				internalType: "string",
				name: "",
				type: "string"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "transferOwnership",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];

var _ROUTER_ADDRESS;
var SupportedChainId;
(function (SupportedChainId) {
  SupportedChainId[SupportedChainId["ETH"] = 1] = "ETH";
  SupportedChainId[SupportedChainId["OPTIMISM"] = 10] = "OPTIMISM";
  SupportedChainId[SupportedChainId["CRONOS"] = 25] = "CRONOS";
  SupportedChainId[SupportedChainId["BSC"] = 56] = "BSC";
  SupportedChainId[SupportedChainId["POLYGON"] = 137] = "POLYGON";
  SupportedChainId[SupportedChainId["FANTOM"] = 250] = "FANTOM";
  SupportedChainId[SupportedChainId["BOBA"] = 288] = "BOBA";
  SupportedChainId[SupportedChainId["METIS"] = 1088] = "METIS";
  SupportedChainId[SupportedChainId["MOONBEAM"] = 1284] = "MOONBEAM";
  SupportedChainId[SupportedChainId["MOONRIVER"] = 1285] = "MOONRIVER";
  SupportedChainId[SupportedChainId["DOGECHAIN"] = 2000] = "DOGECHAIN";
  SupportedChainId[SupportedChainId["CANTO"] = 7700] = "CANTO";
  SupportedChainId[SupportedChainId["KLAYTN"] = 8217] = "KLAYTN";
  SupportedChainId[SupportedChainId["ARBITRUM"] = 42161] = "ARBITRUM";
  SupportedChainId[SupportedChainId["AVALANCHE"] = 43114] = "AVALANCHE";
  SupportedChainId[SupportedChainId["DFK"] = 53935] = "DFK";
  SupportedChainId[SupportedChainId["AURORA"] = 1313161554] = "AURORA";
  SupportedChainId[SupportedChainId["HARMONY"] = 1666600000] = "HARMONY";
})(SupportedChainId || (SupportedChainId = {}));
var ROUTER_ADDRESS = (_ROUTER_ADDRESS = {}, _ROUTER_ADDRESS[SupportedChainId.BSC] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.ETH] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.POLYGON] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.BOBA] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.MOONBEAM] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.MOONRIVER] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.ARBITRUM] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.OPTIMISM] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.AVALANCHE] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.DFK] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.FANTOM] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.HARMONY] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.AURORA] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.CRONOS] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.METIS] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.KLAYTN] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.DOGECHAIN] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS[SupportedChainId.CANTO] = '0x7E7A0e201FD38d3ADAA9523Da6C109a07118C96a', _ROUTER_ADDRESS);
var TradeType;
(function (TradeType) {
  TradeType[TradeType["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType[TradeType["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType || (TradeType = {}));
var Rounding;
(function (Rounding) {
  Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));
var MaxUint256 = /*#__PURE__*/JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

var SynapseRouter = /*#__PURE__*/function () {
  function SynapseRouter(chainId, provider) {
    !(chainId !== undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_ID_UNDEFINED') : invariant(false) : void 0;
    !(provider !== undefined) ? process.env.NODE_ENV !== "production" ? invariant(false, 'PROVIDER_UNDEFINED') : invariant(false) : void 0;
    this.chainId = chainId;
    this.provider = provider;
    this.routerContract = new Contract(ROUTER_ADDRESS[chainId], SynapseRouter.INTERFACE, provider);
  }
  var _proto = SynapseRouter.prototype;
  _proto.getAmountOut = /*#__PURE__*/function () {
    var _getAmountOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenIn, tokenOut, amountIn) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", this.routerContract.getAmountOut(tokenIn, tokenOut, amountIn));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getAmountOut(_x, _x2, _x3) {
      return _getAmountOut.apply(this, arguments);
    }
    return getAmountOut;
  }();
  _proto.getOriginAmountOut = /*#__PURE__*/function () {
    var _getOriginAmountOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenIn, bridgeTokens, amountIn) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.routerContract.getOriginAmountOut(tokenIn, bridgeTokens, amountIn));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getOriginAmountOut(_x4, _x5, _x6) {
      return _getOriginAmountOut.apply(this, arguments);
    }
    return getOriginAmountOut;
  }();
  _proto.getDestinationAmountOut = /*#__PURE__*/function () {
    var _getDestinationAmountOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(requests, tokenOut) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", this.routerContract.getDestinationAmountOut(requests, tokenOut));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getDestinationAmountOut(_x7, _x8) {
      return _getDestinationAmountOut.apply(this, arguments);
    }
    return getDestinationAmountOut;
  }();
  _proto.getConnectedBridgeTokens = /*#__PURE__*/function () {
    var _getConnectedBridgeTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenOut) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", this.routerContract.getConnectedBridgeTokens(tokenOut));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function getConnectedBridgeTokens(_x9) {
      return _getConnectedBridgeTokens.apply(this, arguments);
    }
    return getConnectedBridgeTokens;
  }();
  _proto.bridge = /*#__PURE__*/function () {
    var _bridge = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(to, chainId, token, amount, originQuery, destQuery) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", this.routerContract.populateTransaction.bridge(to, chainId, token, amount, originQuery, destQuery, {
              value: 0
            }));
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function bridge(_x10, _x11, _x12, _x13, _x14, _x15) {
      return _bridge.apply(this, arguments);
    }
    return bridge;
  }();
  return SynapseRouter;
}();
SynapseRouter.INTERFACE = /*#__PURE__*/new Interface(abi);

var bridgeAbi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Paused",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "previousAdminRole",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "newAdminRole",
				type: "bytes32"
			}
		],
		name: "RoleAdminChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleGranted",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				indexed: true,
				internalType: "address",
				name: "account",
				type: "address"
			},
			{
				indexed: true,
				internalType: "address",
				name: "sender",
				type: "address"
			}
		],
		name: "RoleRevoked",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "TokenDeposit",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			}
		],
		name: "TokenDepositAndSwap",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "contract IERC20Mintable",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "TokenMint",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "contract IERC20Mintable",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "swapSuccess",
				type: "bool"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "TokenMintAndSwap",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "TokenRedeem",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "swapTokenIndex",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "swapMinAmount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "swapDeadline",
				type: "uint256"
			}
		],
		name: "TokenRedeemAndRemove",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			}
		],
		name: "TokenRedeemAndSwap",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "bytes32",
				name: "to",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "TokenRedeemV2",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "TokenWithdraw",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				indexed: false,
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint8",
				name: "swapTokenIndex",
				type: "uint8"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "swapMinAmount",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "swapDeadline",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "bool",
				name: "swapSuccess",
				type: "bool"
			},
			{
				indexed: true,
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "TokenWithdrawAndRemove",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: false,
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "Unpaused",
		type: "event"
	},
	{
		inputs: [
		],
		name: "DEFAULT_ADMIN_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "GOVERNANCE_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "NODEGROUP_ROLE",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "WETH_ADDRESS",
		outputs: [
			{
				internalType: "address payable",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32[]",
				name: "kappas",
				type: "bytes32[]"
			}
		],
		name: "addKappas",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "bridgeVersion",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "chainGasAmount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "deposit",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			}
		],
		name: "depositAndSwap",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "tokenAddress",
				type: "address"
			}
		],
		name: "getFeeBalance",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleAdmin",
		outputs: [
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "index",
				type: "uint256"
			}
		],
		name: "getRoleMember",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			}
		],
		name: "getRoleMemberCount",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "grantRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "hasRole",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "initialize",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "kappaExists",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address payable",
				name: "to",
				type: "address"
			},
			{
				internalType: "contract IERC20Mintable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "mint",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address payable",
				name: "to",
				type: "address"
			},
			{
				internalType: "contract IERC20Mintable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				internalType: "contract ISwap",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "mintAndSwap",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "pause",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "paused",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract ERC20Burnable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "redeem",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract ERC20Burnable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "swapTokenIndex",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "swapMinAmount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "swapDeadline",
				type: "uint256"
			}
		],
		name: "redeemAndRemove",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract ERC20Burnable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint8",
				name: "tokenIndexFrom",
				type: "uint8"
			},
			{
				internalType: "uint8",
				name: "tokenIndexTo",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "minDy",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "deadline",
				type: "uint256"
			}
		],
		name: "redeemAndSwap",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "to",
				type: "bytes32"
			},
			{
				internalType: "uint256",
				name: "chainId",
				type: "uint256"
			},
			{
				internalType: "contract ERC20Burnable",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "redeemV2",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "renounceRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "bytes32",
				name: "role",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "account",
				type: "address"
			}
		],
		name: "revokeRole",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			}
		],
		name: "setChainGasAmount",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address payable",
				name: "_wethAddress",
				type: "address"
			}
		],
		name: "setWethAddress",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
		],
		name: "startBlockNumber",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
		],
		name: "unpause",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "withdraw",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "to",
				type: "address"
			},
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "amount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "fee",
				type: "uint256"
			},
			{
				internalType: "contract ISwap",
				name: "pool",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "swapTokenIndex",
				type: "uint8"
			},
			{
				internalType: "uint256",
				name: "swapMinAmount",
				type: "uint256"
			},
			{
				internalType: "uint256",
				name: "swapDeadline",
				type: "uint256"
			},
			{
				internalType: "bytes32",
				name: "kappa",
				type: "bytes32"
			}
		],
		name: "withdrawAndRemove",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "contract IERC20",
				name: "token",
				type: "address"
			},
			{
				internalType: "address",
				name: "to",
				type: "address"
			}
		],
		name: "withdrawFees",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		stateMutability: "payable",
		type: "receive"
	}
];

var SynapseSDK = /*#__PURE__*/function () {
  function SynapseSDK(chainIds, providers) {
    this.bridgeAbi = new Interface(bridgeAbi);
    !(chainIds.length === providers.length) ? process.env.NODE_ENV !== "production" ? invariant(false, "Amount of chains and providers does not equal") : invariant(false) : void 0;
    this.synapseRouters = {};
    this.providers = {};
    for (var i = 0; i < chainIds.length; i++) {
      this.synapseRouters[chainIds[i]] = new SynapseRouter(chainIds[i], providers[i]);
      this.providers[chainIds[i]] = providers[i];
    }
  }
  var _proto = SynapseSDK.prototype;
  _proto.bridgeQuote = /*#__PURE__*/function () {
    var _bridgeQuote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(originChainId, destChainId, tokenIn, tokenOut, amountIn) {
      var originQuery, destQuery, originRouter, destRouter, bridgeTokens, filteredTokens, originQueries, requests, i, destQueries, destInToken, maxAmountOut, _i, feeAmount, feeConfig, routerAddress;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            tokenOut = handleNativeToken(tokenOut);
            tokenIn = handleNativeToken(tokenIn);
            originRouter = this.synapseRouters[originChainId];
            destRouter = this.synapseRouters[destChainId]; // Step 0: find connected bridge tokens on destination
            _context.next = 6;
            return destRouter.routerContract.getConnectedBridgeTokens(tokenOut);
          case 6:
            bridgeTokens = _context.sent;
            if (!(bridgeTokens.length === 0)) {
              _context.next = 9;
              break;
            }
            throw Error('No bridge tokens found for this route');
          case 9:
            filteredTokens = bridgeTokens.filter(function (bridgeToken) {
              return bridgeToken.symbol.length !== 0 && bridgeToken.token !== AddressZero;
            }); // Step 1: perform a call to origin SynapseRouter
            _context.next = 12;
            return originRouter.routerContract.getOriginAmountOut(tokenIn, filteredTokens.map(function (bridgeToken) {
              return bridgeToken.symbol;
            }), amountIn);
          case 12:
            originQueries = _context.sent;
            // Step 2: form a list of Destination Requests
            // In practice, there is no need to pass the requests with amountIn = 0, but we will do it for code simplicity
            requests = [];
            for (i = 0; i < filteredTokens.length; i++) {
              requests.push({
                symbol: filteredTokens[i].symbol,
                amountIn: originQueries[i].minAmountOut
              });
            }
            // Step 3: perform a call to destination SynapseRouter
            _context.next = 17;
            return destRouter.routerContract.getDestinationAmountOut(requests, tokenOut);
          case 17:
            destQueries = _context.sent;
            maxAmountOut = BigNumber.from(0);
            for (_i = 0; _i < destQueries.length; _i++) {
              if (destQueries[_i].minAmountOut.gt(maxAmountOut)) {
                maxAmountOut = destQueries[_i].minAmountOut;
                originQuery = originQueries[_i];
                destQuery = destQueries[_i];
                destInToken = filteredTokens[_i].token;
              }
            }
            // Get fee data
            if (!(originQuery && destInToken)) {
              _context.next = 27;
              break;
            }
            _context.next = 23;
            return destRouter.routerContract.calculateBridgeFee(destInToken, originQuery.minAmountOut);
          case 23:
            feeAmount = _context.sent;
            _context.next = 26;
            return destRouter.routerContract.fee(destInToken);
          case 26:
            feeConfig = _context.sent;
          case 27:
            // Router address so allowance handling be set by client
            routerAddress = originRouter.routerContract.address;
            return _context.abrupt("return", {
              feeAmount: feeAmount,
              feeConfig: feeConfig,
              routerAddress: routerAddress,
              maxAmountOut: maxAmountOut,
              originQuery: originQuery,
              destQuery: destQuery
            });
          case 29:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function bridgeQuote(_x, _x2, _x3, _x4, _x5) {
      return _bridgeQuote.apply(this, arguments);
    }
    return bridgeQuote;
  }();
  _proto.bridge = /*#__PURE__*/function () {
    var _bridge = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(to, originChainId, destChainId, token, amount, originQuery, destQuery) {
      var originRouter;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            token = handleNativeToken(token);
            originRouter = this.synapseRouters[originChainId];
            return _context2.abrupt("return", originRouter.routerContract.populateTransaction.bridge(to, destChainId, token, amount, originQuery, destQuery));
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function bridge(_x6, _x7, _x8, _x9, _x10, _x11, _x12) {
      return _bridge.apply(this, arguments);
    }
    return bridge;
  }() // TODO: add gas from bridge
  ;
  _proto.swapQuote =
  /*#__PURE__*/
  function () {
    var _swapQuote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainId, tokenIn, tokenOut, amountIn) {
      var router, query, routerAddress, maxAmountOut;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            tokenOut = handleNativeToken(tokenOut);
            tokenIn = handleNativeToken(tokenIn);
            router = this.synapseRouters[chainId]; // Step 0: get the swap quote
            _context3.next = 5;
            return router.routerContract.getAmountOut(tokenIn, tokenOut, amountIn);
          case 5:
            query = _context3.sent;
            // Router address so allowance handling be set by client
            routerAddress = router.routerContract.address;
            maxAmountOut = query.minAmountOut;
            return _context3.abrupt("return", {
              routerAddress: routerAddress,
              maxAmountOut: maxAmountOut,
              query: query
            });
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function swapQuote(_x13, _x14, _x15, _x16) {
      return _swapQuote.apply(this, arguments);
    }
    return swapQuote;
  }();
  _proto.swap = /*#__PURE__*/function () {
    var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(chainId, to, token, amount, query) {
      var originRouter;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            token = handleNativeToken(token);
            originRouter = this.synapseRouters[chainId];
            return _context4.abrupt("return", originRouter.routerContract.populateTransaction.swap(to, token, amount, query));
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function swap(_x17, _x18, _x19, _x20, _x21) {
      return _swap.apply(this, arguments);
    }
    return swap;
  }();
  _proto.getBridgeGas = /*#__PURE__*/function () {
    var _getBridgeGas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(chainId) {
      var router, bridgeAddress, bridgeContract;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            router = this.synapseRouters[chainId];
            _context5.next = 3;
            return router.routerContract.synapseBridge();
          case 3:
            bridgeAddress = _context5.sent;
            bridgeContract = new Contract(bridgeAddress, this.bridgeAbi, this.providers[chainId]);
            return _context5.abrupt("return", bridgeContract.chainGasAmount());
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function getBridgeGas(_x22) {
      return _getBridgeGas.apply(this, arguments);
    }
    return getBridgeGas;
  }();
  _proto.getPoolTokens = /*#__PURE__*/function () {
    var _getPoolTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(chainId, poolAddress) {
      var router, poolTokens;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            router = this.synapseRouters[chainId];
            _context6.next = 3;
            return router.routerContract.poolTokens(poolAddress);
          case 3:
            poolTokens = _context6.sent;
            return _context6.abrupt("return", poolTokens.map(function (token) {
              return {
                token: token.token,
                isWeth: token == null ? void 0 : token.isWeth
              };
            }));
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getPoolTokens(_x23, _x24) {
      return _getPoolTokens.apply(this, arguments);
    }
    return getPoolTokens;
  }();
  _proto.getPoolInfo = /*#__PURE__*/function () {
    var _getPoolInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(chainId, poolAddress) {
      var router, poolInfo;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            router = this.synapseRouters[chainId];
            _context7.next = 3;
            return router.routerContract.poolInfo(poolAddress);
          case 3:
            poolInfo = _context7.sent;
            return _context7.abrupt("return", {
              tokens: poolInfo == null ? void 0 : poolInfo[0],
              lpToken: poolInfo == null ? void 0 : poolInfo[1]
            });
          case 5:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function getPoolInfo(_x25, _x26) {
      return _getPoolInfo.apply(this, arguments);
    }
    return getPoolInfo;
  }();
  _proto.getAllPools = /*#__PURE__*/function () {
    var _getAllPools = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(chainId) {
      var router, pools, res;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            router = this.synapseRouters[chainId];
            _context8.next = 3;
            return router.routerContract.allPools();
          case 3:
            pools = _context8.sent;
            res = pools.map(function (pool) {
              return {
                poolAddress: pool == null ? void 0 : pool.pool,
                tokens: pool == null ? void 0 : pool.tokens.map(function (token) {
                  return {
                    token: token.token,
                    isWeth: token == null ? void 0 : token.isWeth
                  };
                }),
                lpToken: pool == null ? void 0 : pool.lpToken
              };
            });
            return _context8.abrupt("return", res);
          case 6:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function getAllPools(_x27) {
      return _getAllPools.apply(this, arguments);
    }
    return getAllPools;
  }();
  _proto.calculateAddLiquidity = /*#__PURE__*/function () {
    var _calculateAddLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(chainId, poolAddress, amounts) {
      var router;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            router = this.synapseRouters[chainId];
            return _context9.abrupt("return", router.routerContract.calculateAddLiquidity(poolAddress, amounts));
          case 2:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function calculateAddLiquidity(_x28, _x29, _x30) {
      return _calculateAddLiquidity.apply(this, arguments);
    }
    return calculateAddLiquidity;
  }();
  _proto.calculateRemoveLiquidity = /*#__PURE__*/function () {
    var _calculateRemoveLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(chainId, poolAddress, amount) {
      var router;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            router = this.synapseRouters[chainId];
            return _context10.abrupt("return", router.routerContract.calculateRemoveLiquidity(poolAddress, amount));
          case 2:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function calculateRemoveLiquidity(_x31, _x32, _x33) {
      return _calculateRemoveLiquidity.apply(this, arguments);
    }
    return calculateRemoveLiquidity;
  }();
  return SynapseSDK;
}();

var _toSignificantRoundin, _toFixedRounding;
var Decimal = /*#__PURE__*/toFormat(_Decimal);
var Big = /*#__PURE__*/toFormat(_Big);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = /*#__PURE__*/function () {
  function Fraction(numerator, denominator) {
    if (denominator === void 0) {
      denominator = JSBI.BigInt(1);
    }
    this.numerator = JSBI.BigInt(numerator);
    this.denominator = JSBI.BigInt(denominator);
  }
  Fraction.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof JSBI || typeof fractionish === 'number' || typeof fractionish === 'string') {
      return new Fraction(fractionish);
    }
    if ('numerator' in fractionish && 'denominator' in fractionish) {
      return fractionish;
    }
    throw new Error('Could not parse fraction');
  }
  // performs floor division
  ;
  var _proto = Fraction.prototype;
  _proto.invert = function invert() {
    return new Fraction(this.denominator, this.numerator);
  };
  _proto.add = function add(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    if (JSBI.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide(other) {
    var otherParsed = Fraction.tryParseFraction(other);
    return new Fraction(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
    !(significantDigits > 0) ? process.env.NODE_ENV !== "production" ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
    !(decimalPlaces >= 0) ? process.env.NODE_ENV !== "production" ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
  /**
   * Helper method for converting any super class back to a fraction
   */;
  _createClass(Fraction, [{
    key: "quotient",
    get: function get() {
      return JSBI.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get() {
      return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get() {
      return new Fraction(this.numerator, this.denominator);
    }
  }]);
  return Fraction;
}();

var Big$1 = /*#__PURE__*/toFormat(_Big);
var CurrencyAmount = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(CurrencyAmount, _Fraction);
  function CurrencyAmount(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !JSBI.lessThanOrEqual(_this.quotient, MaxUint256) ? process.env.NODE_ENV !== "production" ? invariant(false, 'AMOUNT') : invariant(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(currency.decimals));
    return _this;
  }
  /**
   * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount
   *
   * @param currency the currency in the amount
   * @param rawAmount the raw token or ether amount
   */
  CurrencyAmount.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount(currency, rawAmount);
  }
  /**
   * Construct a currency amount with a denominator that is not equal to 1
   *
   * @param currency the currency
   * @param numerator the numerator of the fractional token amount
   * @param denominator the denominator of the fractional token amount
   */;
  CurrencyAmount.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount.prototype;
  _proto.add = function add(other) {
    !this.currency.equals(other.currency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract(other) {
    !this.currency.equals(other.currency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CURRENCY') : invariant(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ''
      };
    }
    Big$1.DP = this.currency.decimals;
    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  _createClass(CurrencyAmount, [{
    key: "wrapped",
    get: function get() {
      if (this.currency.isToken) {
        return this;
      }
      return CurrencyAmount.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
  return CurrencyAmount;
}(Fraction);

var ONE_HUNDRED = /*#__PURE__*/new Fraction( /*#__PURE__*/JSBI.BigInt(100));
/**
 * Converts a fraction to a percent
 *
 * @param fraction the fraction to convert
 */
var toPercent = function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
};
var Percent = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(Percent, _Fraction);
  function Percent() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    /**
     * This boolean prevents a fraction from being interpreted as a Percent
     */
    _this.isPercent = true;
    return _this;
  }
  var _proto = Percent.prototype;
  _proto.add = function add(other) {
    return toPercent(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract(other) {
    return toPercent(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide(other) {
    return toPercent(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
  };
  return Percent;
}(Fraction);

var Price = /*#__PURE__*/function (_Fraction) {
  _inheritsLoose(Price, _Fraction);
  /**
   * Construct a price, either with the base and quote currency amount, or the
   *
   * @param args
   */
  function Price() {
    var _this;
    var baseCurrency;
    var quoteCurrency;
    var denominator;
    var numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  /**
   * Flip the price, switching the base and quote currency
   */
  var _proto = Price.prototype;
  _proto.invert = function invert() {
    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  }
  /**
   * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency
   *
   * @param other the other price
   */;
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  }
  /**
   * Return the amount of quote currency corresponding to a given amount of the base currency
   *
   * @param currencyAmount the amount of base currency to quote against the price
   */;
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.currency.equals(this.baseCurrency) ? process.env.NODE_ENV !== "production" ? invariant(false, 'TOKEN') : invariant(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  }
  /**
   * Get the value scaled by decimals for formatting
   *
   * @private
   */;
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  };
  _createClass(Price, [{
    key: "adjustedForDecimals",
    get: function get() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
  return Price;
}(Fraction);

/**
 * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies
 */
var BaseCurrency =
/**
 * Constructs an instance of the base class `BaseCurrency`.
 *
 * @param chainId the chain ID on which this currency resides
 * @param decimals decimals of the currency
 * @param symbol symbol of the currency
 * @param name of the currency
 */
function BaseCurrency(chainId, decimals, symbol, name) {
  !Number.isSafeInteger(chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_ID') : invariant(false) : void 0;
  !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'DECIMALS') : invariant(false) : void 0;
  this.chainId = chainId;
  this.decimals = decimals;
  this.symbol = symbol;
  this.name = name;
};

/**
 * Represents the native currency of the chain on which it resides, e.g.
 */
var NativeCurrency = /*#__PURE__*/function (_BaseCurrency) {
  _inheritsLoose(NativeCurrency, _BaseCurrency);
  function NativeCurrency() {
    var _this;
    _this = _BaseCurrency.apply(this, arguments) || this;
    _this.isNative = true;
    _this.isToken = false;
    return _this;
  }
  return NativeCurrency;
}(BaseCurrency);

/**
 * Validates an address and returns the parsed (checksummed) version of that address
 *
 * @param address the unchecksummed hex address
 */
var validateAndParseAddress = function validateAndParseAddress(address) {
  try {
    return getAddress(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
};

/**
 * Represents an ERC20 token with a unique address and some metadata.
 */
var Token = /*#__PURE__*/function (_BaseCurrency) {
  _inheritsLoose(Token, _BaseCurrency);
  function Token(chainId, address, decimals, symbol, name) {
    var _this;
    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;
    _this.isNative = false;
    _this.isToken = true;
    _this.address = validateAndParseAddress(address);
    return _this;
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
   *
   * @param other other token to compare
   */
  var _proto = Token.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address === other.address;
  }
  /**
   * Returns true if the address of this token sorts before the address of the other token
   *
   * @param other other token to compare
   * @throws if the tokens have the same address
   * @throws if the tokens are on different chains
   */;
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? process.env.NODE_ENV !== "production" ? invariant(false, 'CHAIN_IDS') : invariant(false) : void 0;
    !(this.address !== other.address) ? process.env.NODE_ENV !== "production" ? invariant(false, 'ADDRESSES') : invariant(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  }
  /**
   * Return this token, which does not need to be wrapped
   */;
  _createClass(Token, [{
    key: "wrapped",
    get: function get() {
      return this;
    }
  }]);
  return Token;
}(BaseCurrency);

/**
 * Known WETH9 implementation addresses, used in our implementation of Ether#wrapped
 */
var WETH9 = {
  1: /*#__PURE__*/new Token(1, '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', 18, 'WETH', 'Wrapped Ether'),
  3: /*#__PURE__*/new Token(3, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'),
  4: /*#__PURE__*/new Token(4, '0xc778417E063141139Fce010982780140Aa0cD5Ab', 18, 'WETH', 'Wrapped Ether'),
  5: /*#__PURE__*/new Token(5, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'),
  42: /*#__PURE__*/new Token(42, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether'),
  10: /*#__PURE__*/new Token(10, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'),
  69: /*#__PURE__*/new Token(69, '0x4200000000000000000000000000000000000006', 18, 'WETH', 'Wrapped Ether'),
  42161: /*#__PURE__*/new Token(42161, '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 18, 'WETH', 'Wrapped Ether'),
  421611: /*#__PURE__*/new Token(421611, '0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681', 18, 'WETH', 'Wrapped Ether')
};

/**
 * Ether is the main usage of a 'native' currency, i.e. for Ethereum mainnet and all testnets
 */
var Ether = /*#__PURE__*/function (_NativeCurrency) {
  _inheritsLoose(Ether, _NativeCurrency);
  function Ether(chainId) {
    return _NativeCurrency.call(this, chainId, 18, 'ETH', 'Ether') || this;
  }
  Ether.onChain = function onChain(chainId) {
    var _this$_etherCache$cha;
    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether(chainId);
  };
  var _proto = Ether.prototype;
  _proto.equals = function equals(other) {
    return other.isNative && other.chainId === this.chainId;
  };
  _createClass(Ether, [{
    key: "wrapped",
    get: function get() {
      var weth9 = WETH9[this.chainId];
      !!!weth9 ? process.env.NODE_ENV !== "production" ? invariant(false, 'WRAPPED') : invariant(false) : void 0;
      return weth9;
    }
  }]);
  return Ether;
}(NativeCurrency);
Ether._etherCache = {};

export { CurrencyAmount, ETH_NATIVE_TOKEN_ADDRESS, Ether, Fraction, NativeCurrency, Percent, Price, SynapseSDK, Token, WETH9 };
//# sourceMappingURL=sdk-router.esm.js.map
