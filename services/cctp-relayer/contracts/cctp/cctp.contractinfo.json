{"solidity/SynapseCCTP.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fc828fb07644f999d6f18438f39c0713cf4d1888cb55951b3211f1f4cce1a05264736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fc828fb07644f999d6f18438f39c0713cf4d1888cb55951b3211f1f4cce1a05264736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26268:8061:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26268:8061:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26268:8061:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"Address\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:IDefaultPool":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"getToken","outputs":[{"internalType":"address","name":"token","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"},{"internalType":"uint256","name":"minDy","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IDefaultPool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"calculateSwap(uint8,uint8,uint256)":"a95b089f","getToken(uint8)":"82b86600","swap(uint8,uint8,uint256,uint256,uint256)":"91695586"}},"solidity/SynapseCCTP.sol:IERC20":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/SynapseCCTP.sol:IMessageTransmitter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextAvailableNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"receiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessageWithCaller","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveMessage(bytes,bytes)":{"notice":"Receives an incoming message, validating the header and passing the body to application-specific handler."},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"notice":"Sends an outgoing message from the source domain, with a specified caller on the destination domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveMessage(bytes,bytes)":{"params":{"message":"The message raw bytes","signature":"The message signature"},"returns":{"success":"bool, true if successful"}},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"details":"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.","params":{"destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"Domain of destination chain","messageBody":"Raw bytes content of message","recipient":"Address of message recipient on destination domain as bytes32"},"returns":{"_0":"nonce reserved by message"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAvailableNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"sendMessageWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"params\":{\"message\":\"The message raw bytes\",\"signature\":\"The message signature\"},\"returns\":{\"success\":\"bool, true if successful\"}},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"details\":\"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.\",\"params\":{\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"Domain of destination chain\",\"messageBody\":\"Raw bytes content of message\",\"recipient\":\"Address of message recipient on destination domain as bytes32\"},\"returns\":{\"_0\":\"nonce reserved by message\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"notice\":\"Receives an incoming message, validating the header and passing the body to application-specific handler.\"},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"notice\":\"Sends an outgoing message from the source domain, with a specified caller on the destination domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IMessageTransmitter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"localDomain()":"8d3638f4","nextAvailableNonce()":"8371744e","receiveMessage(bytes,bytes)":"57ecfd28","sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":"f7259a75"}},"solidity/SynapseCCTP.sol:ISynapseCCTP":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"formattedRequest","type":"bytes"}],"name":"receiveCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"swapParams","type":"bytes"}],"name":"sendCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveCircleToken(bytes,bytes,uint32,bytes)":{"notice":"Receive  Circle token supported by CCTP with the request for the action to take."},"sendCircleToken(address,uint32,address,uint256,uint32,bytes)":{"notice":"Send a Circle token supported by CCTP to a given domain with the request for the action to take on the destination domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveCircleToken(bytes,bytes,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this domain.","params":{"formattedRequest":"Formatted request for the action to take on this domain","message":"Message raw bytes emitted by CCTP MessageTransmitter on origin domain","requestVersion":"Version of the request format","signature":"Circle's attestation for the message obtained from Circle's API"}},"sendCircleToken(address,uint32,address,uint256,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination domain.","params":{"amount":"Amount of tokens to burn","burnToken":"Address of Circle token to burn","destinationDomain":"Domain of destination chain","recipient":"Recipient of the tokens on destination domain","requestVersion":"Version of the request format","swapParams":"Swap parameters for the action to take on the destination domain (could be empty)"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"}],\"name\":\"receiveCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"swapParams\",\"type\":\"bytes\"}],\"name\":\"sendCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this domain.\",\"params\":{\"formattedRequest\":\"Formatted request for the action to take on this domain\",\"message\":\"Message raw bytes emitted by CCTP MessageTransmitter on origin domain\",\"requestVersion\":\"Version of the request format\",\"signature\":\"Circle's attestation for the message obtained from Circle's API\"}},\"sendCircleToken(address,uint32,address,uint256,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination domain.\",\"params\":{\"amount\":\"Amount of tokens to burn\",\"burnToken\":\"Address of Circle token to burn\",\"destinationDomain\":\"Domain of destination chain\",\"recipient\":\"Recipient of the tokens on destination domain\",\"requestVersion\":\"Version of the request format\",\"swapParams\":\"Swap parameters for the action to take on the destination domain (could be empty)\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"notice\":\"Receive  Circle token supported by CCTP with the request for the action to take.\"},\"sendCircleToken(address,uint32,address,uint256,uint32,bytes)\":{\"notice\":\"Send a Circle token supported by CCTP to a given domain with the request for the action to take on the destination domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ISynapseCCTP\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"receiveCircleToken(bytes,bytes,uint32,bytes)":"4a5ae51d","sendCircleToken(address,uint32,address,uint256,uint32,bytes)":"08617500"}},"solidity/SynapseCCTP.sol:ITokenMessenger":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"mintRecipient","type":"bytes32"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"}],"name":"depositForBurnWithCaller","outputs":[{"internalType":"uint64","name":"nonce","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"handleReceiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"localMessageTransmitter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localMinter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"notice":"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event."},"handleReceiveMessage(uint32,bytes32,bytes)":{"notice":"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"details":"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.","params":{"amount":"amount of tokens to burn","burnToken":"address of contract to burn deposited tokens, on local domain","destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"destination domain","mintRecipient":"address of mint recipient on destination domain"},"returns":{"nonce":"unique nonce reserved by message"}},"handleReceiveMessage(uint32,bytes32,bytes)":{"details":"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.","params":{"messageBody":"The message body bytes.","remoteDomain":"The domain where the message originated from.","sender":"The sender of the message (remote TokenMessenger)."},"returns":{"success":"Bool, true if successful."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"mintRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"}],\"name\":\"depositForBurnWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"handleReceiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMessageTransmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"details\":\"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.\",\"params\":{\"amount\":\"amount of tokens to burn\",\"burnToken\":\"address of contract to burn deposited tokens, on local domain\",\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"destination domain\",\"mintRecipient\":\"address of mint recipient on destination domain\"},\"returns\":{\"nonce\":\"unique nonce reserved by message\"}},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"details\":\"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.\",\"params\":{\"messageBody\":\"The message body bytes.\",\"remoteDomain\":\"The domain where the message originated from.\",\"sender\":\"The sender of the message (remote TokenMessenger).\"},\"returns\":{\"success\":\"Bool, true if successful.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"notice\":\"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event.\"},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"notice\":\"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ITokenMessenger\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":"f856ddb6","handleReceiveMessage(uint32,bytes32,bytes)":"96abeb70","localMessageTransmitter()":"2c121921","localMinter()":"cb75c11c"}},"solidity/SynapseCCTP.sol:ITokenMinter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"remoteToken","type":"bytes32"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"internalType":"bytes32","name":"burnToken","type":"bytes32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"address","name":"mintToken","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"burn(address,uint256)":{"notice":"Burn tokens owned by this ITokenMinter."},"getLocalToken(uint32,bytes32)":{"notice":"Get the local token associated with the given remote domain and token."},"mint(uint32,bytes32,address,uint256)":{"notice":"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address."}},"version":1},"developerDoc":{"kind":"dev","methods":{"burn(address,uint256)":{"params":{"amount":"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.","burnToken":"burnable token."}},"getLocalToken(uint32,bytes32)":{"params":{"remoteDomain":"Remote domain","remoteToken":"Remote token"},"returns":{"_0":"local token address"}},"mint(uint32,bytes32,address,uint256)":{"details":"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().","params":{"amount":"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.","burnToken":"Burned token address as bytes32.","sourceDomain":"Source domain where `burnToken` was burned.","to":"Address to receive minted tokens, corresponding to `burnToken`, on this domain."},"returns":{"mintToken":"token minted."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"burnToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"burn(address,uint256)\":{\"params\":{\"amount\":\"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.\",\"burnToken\":\"burnable token.\"}},\"getLocalToken(uint32,bytes32)\":{\"params\":{\"remoteDomain\":\"Remote domain\",\"remoteToken\":\"Remote token\"},\"returns\":{\"_0\":\"local token address\"}},\"mint(uint32,bytes32,address,uint256)\":{\"details\":\"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().\",\"params\":{\"amount\":\"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.\",\"burnToken\":\"Burned token address as bytes32.\",\"sourceDomain\":\"Source domain where `burnToken` was burned.\",\"to\":\"Address to receive minted tokens, corresponding to `burnToken`, on this domain.\"},\"returns\":{\"mintToken\":\"token minted.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burn(address,uint256)\":{\"notice\":\"Burn tokens owned by this ITokenMinter.\"},\"getLocalToken(uint32,bytes32)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"mint(uint32,bytes32,address,uint256)\":{\"notice\":\"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ITokenMinter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"burn(address,uint256)":"9dc29fac","getLocalToken(uint32,bytes32)":"78a0565e","mint(uint32,bytes32,address,uint256)":"d54de06f"}},"solidity/SynapseCCTP.sol:MinimalForwarderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f307cfade7290b01ce378a32f68375b6d314d10850206360baf8e68a7d5c31dc64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f307cfade7290b01ce378a32f68375b6d314d10850206360baf8e68a7d5c31dc64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"43858:4120:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;43858:4120:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"43858:4120:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that forwards all calls to a any target address with any payload. Unlike EIP-1167, delegates calls are not used, so the forwarder contract is `msg.sender` as far as the target contract is concerned. # Minimal Forwarder Bytecode Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167). Following changes were made: - Target address is not saved in the deployed contract code, but is passed as a part of the payload. - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload. - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes. - The target address is derived using CALLDATALOAD. - CALLVALUE is used to pass the msg.value to the target contract. - `call()` is used instead of `delegatecall()`. ## Bytecode Table | Pos  | Opcode | Opcode + Args | Description    | Stack View                    | | ---- | ------ | ------------- | -------------- | ----------------------------- | | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            | | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        | | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      | | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             | | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          | | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         | | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      | | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    | | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  | | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                | | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                | | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              | | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          | | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        | | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     | | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 | | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         | | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     | | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   | | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 | | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         | | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         | | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     | | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     | | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                | | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         | | 0x1d | 0xfd   | 0xfd          | revert         |                               | | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         | | 0x1f | 0xf3   | 0xf3          | return         |                               | \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any). \u003e - Stack View is shown after the execution of the opcode. \u003e - `cds` refers to the calldata size. \u003e - `rds` refers to the returndata size (which is zero before the first external call). \u003e - `val` refers to the provided `msg.value`. \u003e - `addr` refers to the target address loaded from calldata. \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left. \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success. ## Bytecode Explanation - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address). \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack. - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\". \u003e - `dup1` duplicates the top stack item. - `0x05..0x08` - Copy the target call payload to memory. \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements: \u003e memory offset to write to, calldata offset to read from, and length of the data to copy. - `0x09..0x11` - Prepare the stack for the `call` opcode. \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero \u003e after we perform the first external call. \u003e - `swap3` swaps the top stack item with the fourth stack item. \u003e - `callvalue` pushes `msg.value` onto the stack. \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack. \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address. \u003e - `gas` pushes the remaining gas onto the stack. - `0x12..0x12` - Call the target contract. \u003e - `call` issues an external call to a target address. \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length, \u003e memory offset to write return data to, and length of return data to write to memory. \u003e - Pushes on stack: 0 on failure, 1 on success. - `0x13..0x16` - Copy the return data to memory. \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack. \u003e - `dup3` duplicates the third stack item. \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements: \u003e memory offset to write to, return data offset to read from, and length of the data to copy. - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size. \u003e - `swap1` swaps the top stack item with the second stack item. \u003e - `swap2` swaps the top stack item with the third stack item. \u003e - `0x1e` refers to the position of the `jumpdest` opcode. \u003e  It is used to jump to the `return` opcode, if call was successful. - `0x1c..0x1c` - Jump to 0x1e position, if call was successful. \u003e - `jumpi` pops two top stack items: jump destination and jump condition. \u003e If jump condition is nonzero, jumps to the jump destination. - `0x1d..0x1d` - Revert if call was unsuccessful. \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message. \u003e - This allows us to bubble the revert message from the external call. - `0x1e..0x1e` - Jump destination for successful call. \u003e - `jumpdest` is a no-op that marks a valid jump destination. - `0x1f..0x1f` - Return if call was successful. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to reuse the return data from the external call. # Minimal Forwarder Init Code Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol). Following changes were made: - Adjusted bytecode length to 32 bytes. - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack. \u003e `bytecode` refers to the bytecode specified in the above table. ## Init Code Table | Pos  | Opcode | Opcode + Args | Description     | Stack View | | ---- | ------ | ------------- | --------------- | ---------- | | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   | | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode | | 0x1c | 0x52   | 0x52          | mstore          |            | | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         | | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       | | 0x20 | 0xf3   | 0xf3          | return          |            | \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code. \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode. ## Init Code Explanation - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack. \u003e - `push32` pushes 32 bytes as a single stack item onto the stack. - `0x1b..0x1b` - Push 0 onto the stack. \u003e No external calls were made, so the return data size is 0. - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory. \u003e - `mstore` pops two top stack items: memory offset to write to and value to write. \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory. - `0x1d..0x1f` - Prepare stack for `return` opcode. \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory. - `0x20..0x20` - Return the Minimal Forwarder bytecode. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to return the Minimal Forwarder bytecode.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that forwards all calls to a any target address with any payload. Unlike EIP-1167, delegates calls are not used, so the forwarder contract is `msg.sender` as far as the target contract is concerned. # Minimal Forwarder Bytecode Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167). Following changes were made: - Target address is not saved in the deployed contract code, but is passed as a part of the payload. - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload. - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes. - The target address is derived using CALLDATALOAD. - CALLVALUE is used to pass the msg.value to the target contract. - `call()` is used instead of `delegatecall()`. ## Bytecode Table | Pos  | Opcode | Opcode + Args | Description    | Stack View                    | | ---- | ------ | ------------- | -------------- | ----------------------------- | | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            | | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        | | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      | | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             | | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          | | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         | | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      | | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    | | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  | | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                | | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                | | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              | | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          | | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        | | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     | | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 | | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         | | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     | | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   | | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 | | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         | | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         | | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     | | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     | | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                | | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         | | 0x1d | 0xfd   | 0xfd          | revert         |                               | | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         | | 0x1f | 0xf3   | 0xf3          | return         |                               | \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any). \u003e - Stack View is shown after the execution of the opcode. \u003e - `cds` refers to the calldata size. \u003e - `rds` refers to the returndata size (which is zero before the first external call). \u003e - `val` refers to the provided `msg.value`. \u003e - `addr` refers to the target address loaded from calldata. \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left. \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success. ## Bytecode Explanation - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address). \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack. - `0x04..0x04` - Duplicate the offset to use it later as \\\"payload length\\\". \u003e - `dup1` duplicates the top stack item. - `0x05..0x08` - Copy the target call payload to memory. \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements: \u003e memory offset to write to, calldata offset to read from, and length of the data to copy. - `0x09..0x11` - Prepare the stack for the `call` opcode. \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero \u003e after we perform the first external call. \u003e - `swap3` swaps the top stack item with the fourth stack item. \u003e - `callvalue` pushes `msg.value` onto the stack. \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack. \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address. \u003e - `gas` pushes the remaining gas onto the stack. - `0x12..0x12` - Call the target contract. \u003e - `call` issues an external call to a target address. \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length, \u003e memory offset to write return data to, and length of return data to write to memory. \u003e - Pushes on stack: 0 on failure, 1 on success. - `0x13..0x16` - Copy the return data to memory. \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack. \u003e - `dup3` duplicates the third stack item. \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements: \u003e memory offset to write to, return data offset to read from, and length of the data to copy. - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size. \u003e - `swap1` swaps the top stack item with the second stack item. \u003e - `swap2` swaps the top stack item with the third stack item. \u003e - `0x1e` refers to the position of the `jumpdest` opcode. \u003e  It is used to jump to the `return` opcode, if call was successful. - `0x1c..0x1c` - Jump to 0x1e position, if call was successful. \u003e - `jumpi` pops two top stack items: jump destination and jump condition. \u003e If jump condition is nonzero, jumps to the jump destination. - `0x1d..0x1d` - Revert if call was unsuccessful. \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message. \u003e - This allows us to bubble the revert message from the external call. - `0x1e..0x1e` - Jump destination for successful call. \u003e - `jumpdest` is a no-op that marks a valid jump destination. - `0x1f..0x1f` - Return if call was successful. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to reuse the return data from the external call. # Minimal Forwarder Init Code Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol). Following changes were made: - Adjusted bytecode length to 32 bytes. - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack. \u003e `bytecode` refers to the bytecode specified in the above table. ## Init Code Table | Pos  | Opcode | Opcode + Args | Description     | Stack View | | ---- | ------ | ------------- | --------------- | ---------- | | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   | | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode | | 0x1c | 0x52   | 0x52          | mstore          |            | | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         | | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       | | 0x20 | 0xf3   | 0xf3          | return          |            | \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code. \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode. ## Init Code Explanation - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack. \u003e - `push32` pushes 32 bytes as a single stack item onto the stack. - `0x1b..0x1b` - Push 0 onto the stack. \u003e No external calls were made, so the return data size is 0. - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory. \u003e - `mstore` pops two top stack items: memory offset to write to and value to write. \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory. - `0x1d..0x1f` - Prepare stack for `return` opcode. \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory. - `0x20..0x20` - Return the Minimal Forwarder bytecode. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to return the Minimal Forwarder bytecode.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"MinimalForwarderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209ca1acaa574c66f31b02db6897319423cddde8143106c8b212473ea01febe71364736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212209ca1acaa574c66f31b02db6897319423cddde8143106c8b212473ea01febe71364736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"17250:8527:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;17250:8527:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"17250:8527:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"# Memory layout of common Request fields for versions [REQUEST_BASE, ...) \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot. | Position   | Field           | Type    | Bytes | Description                                        | | ---------- | --------------- | ------- | ----- | -------------------------------------------------- | | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         | | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         | | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      | | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           | | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      | # Memory layout of common Request fields for versions [REQUEST_SWAP, ...) \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot. \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16. \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token. | Position   | Field           | Type    | Bytes | Description                                        | | ---------- | --------------- | ------- | ----- | -------------------------------------------------- | | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           | | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       | | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               | | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               | | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"# Memory layout of common Request fields for versions [REQUEST_BASE, ...) \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot. | Position   | Field           | Type    | Bytes | Description                                        | | ---------- | --------------- | ------- | ----- | -------------------------------------------------- | | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         | | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         | | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      | | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           | | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      | # Memory layout of common Request fields for versions [REQUEST_SWAP, ...) \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot. \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16. \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token. | Position   | Field           | Type    | Bytes | Description                                        | | ---------- | --------------- | ------- | ----- | -------------------------------------------------- | | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           | | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       | | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               | | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               | | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SafeERC20":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220594c83648e7d75d49f1b534f5358fa6b59362c6b3c97c27a6271888fb6ca79e664736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220594c83648e7d75d49f1b534f5358fa6b59362c6b3c97c27a6271888fb6ca79e664736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"51217:3270:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;51217:3270:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"51217:3270:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.","kind":"dev","methods":{},"title":"SafeERC20","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"SafeERC20\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SafeERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SlicerLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122049ef00c9b41b262d67087f130937881653f1fb80469b1aa1603332f6fc4378c964736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122049ef00c9b41b262d67087f130937881653f1fb80469b1aa1603332f6fc4378c964736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"12016:3089:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;12016:3089:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"12016:3089:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Library for slicing bytes arrays. # BytesArray stack layout (from highest bits to lowest) | Position   | Field | Type    | Bytes | Description                              | | ---------- | ----- | ------- | ----- | ---------------------------------------- | | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array | | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for slicing bytes arrays. # BytesArray stack layout (from highest bits to lowest) | Position   | Field | Type    | Bytes | Description                              | | ---------- | ----- | ------- | ----- | ---------------------------------------- | | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array | | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SlicerLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SynapseCCTP":{"code":"0x60e06040523480156200001157600080fd5b50604051620024e9380380620024e983398101604081905262000034916200013e565b6001600160a01b03811660c081905260408051632c12192160e01b81529051632c121921916004808201926020929091908290030181865afa1580156200007f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000a591906200013e565b6001600160a01b031660a08190526040805163234d8e3d60e21b81529051638d3638f4916004808201926020929091908290030181865afa158015620000ef573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000115919062000165565b63ffffffff16608052506200018d565b6001600160a01b03811681146200013b57600080fd5b50565b6000602082840312156200015157600080fd5b81516200015e8162000125565b9392505050565b6000602082840312156200017857600080fd5b815163ffffffff811681146200015e57600080fd5b60805160a05160c0516122fb620001ee600039600081816101170152818161041501528181610451015261058701526000818161017b0152818161022a0152610f8a0152600081816101a2015281816102bd01526107d701526122fb6000f3fe608060405234801561001057600080fd5b50600436106100a35760003560e01c80634a5ae51d116100765780638d3638f41161005b5780638d3638f41461019d578063e8eb1df0146101d9578063f879a41a1461020757600080fd5b80634a5ae51d146101635780637b04c1811461017657600080fd5b806308617500146100a8578063242fdf1d146100bd578063393e5b60146100ff5780634611783014610112575b600080fd5b6100bb6100b6366004611e13565b61021a565b005b6100bb6100cb366004611e9f565b73ffffffffffffffffffffffffffffffffffffffff811663ffffffff90921660009081526020819052604090209190915550565b6100bb61010d366004611e9f565b610583565b6101397f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100bb610171366004611f18565b6107b5565b6101397f000000000000000000000000000000000000000000000000000000000000000081565b6101c47f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161015a565b6101f96101e7366004611fb1565b60006020819052908152604090205481565b60405190815260200161015a565b610139610215366004611e9f565b6108d6565b6102248484610925565b925060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638371744e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610293573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b79190611fcc565b604080517f000000000000000000000000000000000000000000000000000000000000000060e01b7fffffffff0000000000000000000000000000000000000000000000000000000016602082015260c083901b7fffffffffffffffff000000000000000000000000000000000000000000000000166024820152606088811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116602c8401528284018990528b821b169082015281516054818303018152607490910190915290915060009061039290859085610a7e565b63ffffffff88166000908152602081905260408120549192508190036103e4576040517fa86a3b0e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b815160208084019190912067ffffffff000000008a831b1663ffffffff881617600090815291526040902061043a887f000000000000000000000000000000000000000000000000000000000000000089610c43565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663f856ddb6888b858c6104848288610d56565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b168152600481019590955263ffffffff939093166024850152604484019190915273ffffffffffffffffffffffffffffffffffffffff166064830152608482015260a4016020604051808303816000875af1158015610510573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105349190611fcc565b50807f6e7df7fbb64a0b631dd90e0dffa7f84a3d04e73eb844cf7be956d4c7e3bbdc728a868b8b8b8960405161056f96959493929190612046565b60405180910390a250505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663cb75c11c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061491906120ad565b905060008173ffffffffffffffffffffffffffffffffffffffff166378a0565e856106688673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815263ffffffff9290921660048301526024820152604401602060405180830381865afa1580156106c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106eb91906120ad565b905073ffffffffffffffffffffffffffffffffffffffff811661073a576040517f74e3d32e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b77ffffffff000000000000000000000000000000000000000060a09490941b9390931673ffffffffffffffffffffffffffffffffffffffff92831617600090815260016020526040902080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169390921692909217905550565b60006107c18383610d9b565b825160208085019190912067ffffffff000000007f0000000000000000000000000000000000000000000000000000000000000000831b1663ffffffff871617600090815291526040902090915061081c8888888885610edf565b60008061082884610fb9565b915091506000610838838361105a565b9092509050600061084886611065565b905060008061085a8387878d8c611087565b6040805173ffffffffffffffffffffffffffffffffffffffff8a8116825260208201899052848116828401526060820184905291519395509193508992908616917feaf2537b3a5c10387b14e2c0e57b1e11b46ff39b0f4ead5dac98cb0f4fd2118f919081900360800190a35050505050505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff81811660a084901b77ffffffff00000000000000000000000000000000000000001617600090815260016020526040902054165b92915050565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152600090819073ffffffffffffffffffffffffffffffffffffffff8516906370a0823190602401602060405180830381865afa158015610994573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b891906120ca565b90506109dc73ffffffffffffffffffffffffffffffffffffffff8516333086611163565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152819073ffffffffffffffffffffffffffffffffffffffff8616906370a0823190602401602060405180830381865afa158015610a48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a6c91906120ca565b610a769190612112565b949350505050565b6060600163ffffffff85161115610ac1576040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610acd60006020612125565b610ad8906020612125565b610ae3906014612125565b835114610b1c576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8416158015610b305750815115155b15610b67576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff84166001148015610be15750610b8460006020612125565b610b8f906020612125565b610b9a906014612125565b610ba660006020612125565b610bb1906020612125565b610bbc906014612125565b610bc7906020612125565b610bd2906020612125565b610bdc9190612112565b825114155b15610c18576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8282604051602001610c2b929190612138565b60405160208183030381529060405290509392505050565b6040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff83811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015610cb9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cdd91906120ca565b905081811015610d50578015610d0f57610d0f73ffffffffffffffffffffffffffffffffffffffff8516846000611221565b610d5073ffffffffffffffffffffffffffffffffffffffff8516847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611221565b50505050565b6000610d94610d7b73ffffffffffffffffffffffffffffffffffffffff8516846113ad565b73ffffffffffffffffffffffffffffffffffffffff1690565b9392505050565b6000600163ffffffff84161115610dde576040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8316158015610e145750610df960006020612125565b610e04906020612125565b610e0f906014612125565b825114155b15610e4b576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff83166001148015610e995750610e6860006020612125565b610e73906020612125565b610e7e906014612125565b610e89906020612125565b610e94906020612125565b825114155b15610ed0576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81516020830160801b17610d94565b6000610eea82611499565b905060006357ecfd2860e01b87878787604051602401610f0d9493929190612192565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091529050610faf73ffffffffffffffffffffffffffffffffffffffff83167f000000000000000000000000000000000000000000000000000000000000000083611552565b5050505050505050565b600080600080610fc885611561565b73ffffffffffffffffffffffffffffffffffffffff80831660a086901b77ffffffff000000000000000000000000000000000000000016176000908152600160205260409020541697509550919350909150849050611053576040517f5ec62f3300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050915091565b8060005b9250929050565b600061091f611075826020612125565b611080906020612125565b83906115c8565b60008063ffffffff84166110a9576110a0878787611666565b91509150611159565b60008060008060006110ba88611691565b945094509450945094506110ce8584611736565b965073ffffffffffffffffffffffffffffffffffffffff8716611104576110f68c8c8c611666565b965096505050505050611159565b61110f8b868c610c43565b61111d8585858d86866117ce565b955085600003611132576110f68c8c8c611666565b61115373ffffffffffffffffffffffffffffffffffffffff88168d8861189d565b50505050505b9550959350505050565b60405173ffffffffffffffffffffffffffffffffffffffff80851660248301528316604482015260648101829052610d509085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091526118f3565b8015806112c157506040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff838116602483015284169063dd62ed3e90604401602060405180830381865afa15801561129b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bf91906120ca565b155b611352576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e63650000000000000000000060648201526084015b60405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526113a89084907f095ea7b300000000000000000000000000000000000000000000000000000000906064016111bd565b505050565b6000610d9483836040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016113fa91906121b9565b60405160208183030381529060405280519060200120604051602001611480939291907fff00000000000000000000000000000000000000000000000000000000000000815260609390931b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660018401526015830191909152603582015260550190565b6040516020818303038152906040528051906020012090565b6000806040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016114e291906121b9565b6040516020818303038152906040529050828151602083016000f5915073ffffffffffffffffffffffffffffffffffffffff821661154c576040517f27afa9fc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b6060610a7684848460006119ff565b60008080808061157381875b90611a64565b90508060e01c945067ffffffffffffffff8160a01c16935073ffffffffffffffffffffffffffffffffffffffff811692506115bb600060206115b59190612125565b8761156d565b60001c9150509193509193565b6000608083901c6fffffffffffffffffffffffffffffffff841680841061161b576040517fdfc52d7b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80846014011115611658576040517f4b72f29d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b509091015160601c92915050565b818161168973ffffffffffffffffffffffffffffffffffffffff8316868361189d565b935093915050565b600080808080806116c26116a6826020612125565b6116b1906020612125565b6116bc906014612125565b8861156d565b90508060601c955060ff8160581c16945060ff8160501c16935073ffffffffffffffffffffffffffffffffffffffff81169250611727600060206117069190612125565b611711906020612125565b61171c906014612125565b6116bc906020612125565b60001c91505091939590929450565b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff8216600482015260009073ffffffffffffffffffffffffffffffffffffffff8416906382b8660090602401602060405180830381865afa9250505080156117c2575060408051601f3d908101601f191682019092526117bf918101906120ad565b60015b610d945750600061091f565b6040517f9169558600000000000000000000000000000000000000000000000000000000815260ff808716600483015285166024820152604481018490526064810182905269ffffffffffffffffffff8316608482015260009073ffffffffffffffffffffffffffffffffffffffff88169063916955869060a4016020604051808303816000875af1925050508015611884575060408051601f3d908101601f19168201909252611881918101906120ca565b60015b61189057506000611893565b90505b9695505050505050565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526113a89084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016111bd565b6000611955826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16611aff9092919063ffffffff16565b8051909150156113a857808060200190518101906119739190612225565b6113a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401611349565b6060611a5b73ffffffffffffffffffffffffffffffffffffffff851684604051602001611a2d929190612247565b60408051601f1981840301815291905273ffffffffffffffffffffffffffffffffffffffff87169084611b0e565b95945050505050565b6000608083901c6fffffffffffffffffffffffffffffffff8416808410611ab7576040517fdfc52d7b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80846020011115611af4576040517f4b72f29d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b509091015192915050565b6060610a768484600085611b30565b6060610a7684848460405180606001604052806029815260200161229d602991395b606082471015611bc2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401611349565b73ffffffffffffffffffffffffffffffffffffffff85163b611c40576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401611349565b6000808673ffffffffffffffffffffffffffffffffffffffff168587604051611c69919061226d565b60006040518083038185875af1925050503d8060008114611ca6576040519150601f19603f3d011682016040523d82523d6000602084013e611cab565b606091505b5091509150611cbb828286611cc6565b979650505050505050565b60608315611cd5575081610d94565b825115611ce55782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113499190612289565b73ffffffffffffffffffffffffffffffffffffffff81168114611d3b57600080fd5b50565b803563ffffffff81168114611d5257600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112611d9757600080fd5b813567ffffffffffffffff80821115611db257611db2611d57565b604051601f8301601f19908116603f01168101908282118183101715611dda57611dda611d57565b81604052838152866020858801011115611df357600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060008060008060c08789031215611e2c57600080fd5b8635611e3781611d19565b9550611e4560208801611d3e565b94506040870135611e5581611d19565b935060608701359250611e6a60808801611d3e565b915060a087013567ffffffffffffffff811115611e8657600080fd5b611e9289828a01611d86565b9150509295509295509295565b60008060408385031215611eb257600080fd5b611ebb83611d3e565b91506020830135611ecb81611d19565b809150509250929050565b60008083601f840112611ee857600080fd5b50813567ffffffffffffffff811115611f0057600080fd5b60208301915083602082850101111561105e57600080fd5b60008060008060008060808789031215611f3157600080fd5b863567ffffffffffffffff80821115611f4957600080fd5b611f558a838b01611ed6565b90985096506020890135915080821115611f6e57600080fd5b611f7a8a838b01611ed6565b9096509450849150611f8e60408a01611d3e565b93506060890135915080821115611fa457600080fd5b50611e9289828a01611d86565b600060208284031215611fc357600080fd5b610d9482611d3e565b600060208284031215611fde57600080fd5b815167ffffffffffffffff81168114610d9457600080fd5b60005b83811015612011578181015183820152602001611ff9565b50506000910152565b60008151808452612032816020860160208601611ff6565b601f01601f19169290920160200192915050565b600063ffffffff808916835267ffffffffffffffff8816602084015273ffffffffffffffffffffffffffffffffffffffff8716604084015285606084015280851660808401525060c060a08301526120a160c083018461201a565b98975050505050505050565b6000602082840312156120bf57600080fd5b8151610d9481611d19565b6000602082840312156120dc57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561091f5761091f6120e3565b8082018082111561091f5761091f6120e3565b6000835161214a818460208801611ff6565b83519083019061215e818360208801611ff6565b01949350505050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b6040815260006121a6604083018688612167565b8281036020840152611cbb818587612167565b7f7f000000000000000000000000000000000000000000000000000000000000008152600082516121f1816001850160208701611ff6565b7f3d5260203df300000000000000000000000000000000000000000000000000006001939091019283015250600701919050565b60006020828403121561223757600080fd5b81518015158114610d9457600080fd5b8281526000825161225f816020850160208701611ff6565b919091016020019392505050565b6000825161227f818460208701611ff6565b9190910192915050565b602081526000610d94602083018461201a56fe416464726573733a206c6f772d6c6576656c2063616c6c20776974682076616c7565206661696c6564a2646970667358221220060b52138225159131259d6cde225506f670307a9634d5a5c057476b1bfe617f64736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100a35760003560e01c80634a5ae51d116100765780638d3638f41161005b5780638d3638f41461019d578063e8eb1df0146101d9578063f879a41a1461020757600080fd5b80634a5ae51d146101635780637b04c1811461017657600080fd5b806308617500146100a8578063242fdf1d146100bd578063393e5b60146100ff5780634611783014610112575b600080fd5b6100bb6100b6366004611e13565b61021a565b005b6100bb6100cb366004611e9f565b73ffffffffffffffffffffffffffffffffffffffff811663ffffffff90921660009081526020819052604090209190915550565b6100bb61010d366004611e9f565b610583565b6101397f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100bb610171366004611f18565b6107b5565b6101397f000000000000000000000000000000000000000000000000000000000000000081565b6101c47f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161015a565b6101f96101e7366004611fb1565b60006020819052908152604090205481565b60405190815260200161015a565b610139610215366004611e9f565b6108d6565b6102248484610925565b925060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638371744e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610293573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102b79190611fcc565b604080517f000000000000000000000000000000000000000000000000000000000000000060e01b7fffffffff0000000000000000000000000000000000000000000000000000000016602082015260c083901b7fffffffffffffffff000000000000000000000000000000000000000000000000166024820152606088811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000908116602c8401528284018990528b821b169082015281516054818303018152607490910190915290915060009061039290859085610a7e565b63ffffffff88166000908152602081905260408120549192508190036103e4576040517fa86a3b0e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b815160208084019190912067ffffffff000000008a831b1663ffffffff881617600090815291526040902061043a887f000000000000000000000000000000000000000000000000000000000000000089610c43565b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663f856ddb6888b858c6104848288610d56565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b168152600481019590955263ffffffff939093166024850152604484019190915273ffffffffffffffffffffffffffffffffffffffff166064830152608482015260a4016020604051808303816000875af1158015610510573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105349190611fcc565b50807f6e7df7fbb64a0b631dd90e0dffa7f84a3d04e73eb844cf7be956d4c7e3bbdc728a868b8b8b8960405161056f96959493929190612046565b60405180910390a250505050505050505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663cb75c11c6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105f0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061491906120ad565b905060008173ffffffffffffffffffffffffffffffffffffffff166378a0565e856106688673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815263ffffffff9290921660048301526024820152604401602060405180830381865afa1580156106c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106eb91906120ad565b905073ffffffffffffffffffffffffffffffffffffffff811661073a576040517f74e3d32e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b77ffffffff000000000000000000000000000000000000000060a09490941b9390931673ffffffffffffffffffffffffffffffffffffffff92831617600090815260016020526040902080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169390921692909217905550565b60006107c18383610d9b565b825160208085019190912067ffffffff000000007f0000000000000000000000000000000000000000000000000000000000000000831b1663ffffffff871617600090815291526040902090915061081c8888888885610edf565b60008061082884610fb9565b915091506000610838838361105a565b9092509050600061084886611065565b905060008061085a8387878d8c611087565b6040805173ffffffffffffffffffffffffffffffffffffffff8a8116825260208201899052848116828401526060820184905291519395509193508992908616917feaf2537b3a5c10387b14e2c0e57b1e11b46ff39b0f4ead5dac98cb0f4fd2118f919081900360800190a35050505050505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff81811660a084901b77ffffffff00000000000000000000000000000000000000001617600090815260016020526040902054165b92915050565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152600090819073ffffffffffffffffffffffffffffffffffffffff8516906370a0823190602401602060405180830381865afa158015610994573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b891906120ca565b90506109dc73ffffffffffffffffffffffffffffffffffffffff8516333086611163565b6040517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152819073ffffffffffffffffffffffffffffffffffffffff8616906370a0823190602401602060405180830381865afa158015610a48573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a6c91906120ca565b610a769190612112565b949350505050565b6060600163ffffffff85161115610ac1576040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610acd60006020612125565b610ad8906020612125565b610ae3906014612125565b835114610b1c576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8416158015610b305750815115155b15610b67576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff84166001148015610be15750610b8460006020612125565b610b8f906020612125565b610b9a906014612125565b610ba660006020612125565b610bb1906020612125565b610bbc906014612125565b610bc7906020612125565b610bd2906020612125565b610bdc9190612112565b825114155b15610c18576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8282604051602001610c2b929190612138565b60405160208183030381529060405290509392505050565b6040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff83811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015610cb9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cdd91906120ca565b905081811015610d50578015610d0f57610d0f73ffffffffffffffffffffffffffffffffffffffff8516846000611221565b610d5073ffffffffffffffffffffffffffffffffffffffff8516847fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611221565b50505050565b6000610d94610d7b73ffffffffffffffffffffffffffffffffffffffff8516846113ad565b73ffffffffffffffffffffffffffffffffffffffff1690565b9392505050565b6000600163ffffffff84161115610dde576040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8316158015610e145750610df960006020612125565b610e04906020612125565b610e0f906014612125565b825114155b15610e4b576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff83166001148015610e995750610e6860006020612125565b610e73906020612125565b610e7e906014612125565b610e89906020612125565b610e94906020612125565b825114155b15610ed0576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81516020830160801b17610d94565b6000610eea82611499565b905060006357ecfd2860e01b87878787604051602401610f0d9493929190612192565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091529050610faf73ffffffffffffffffffffffffffffffffffffffff83167f000000000000000000000000000000000000000000000000000000000000000083611552565b5050505050505050565b600080600080610fc885611561565b73ffffffffffffffffffffffffffffffffffffffff80831660a086901b77ffffffff000000000000000000000000000000000000000016176000908152600160205260409020541697509550919350909150849050611053576040517f5ec62f3300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050915091565b8060005b9250929050565b600061091f611075826020612125565b611080906020612125565b83906115c8565b60008063ffffffff84166110a9576110a0878787611666565b91509150611159565b60008060008060006110ba88611691565b945094509450945094506110ce8584611736565b965073ffffffffffffffffffffffffffffffffffffffff8716611104576110f68c8c8c611666565b965096505050505050611159565b61110f8b868c610c43565b61111d8585858d86866117ce565b955085600003611132576110f68c8c8c611666565b61115373ffffffffffffffffffffffffffffffffffffffff88168d8861189d565b50505050505b9550959350505050565b60405173ffffffffffffffffffffffffffffffffffffffff80851660248301528316604482015260648101829052610d509085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091526118f3565b8015806112c157506040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff838116602483015284169063dd62ed3e90604401602060405180830381865afa15801561129b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bf91906120ca565b155b611352576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e63650000000000000000000060648201526084015b60405180910390fd5b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526113a89084907f095ea7b300000000000000000000000000000000000000000000000000000000906064016111bd565b505050565b6000610d9483836040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016113fa91906121b9565b60405160208183030381529060405280519060200120604051602001611480939291907fff00000000000000000000000000000000000000000000000000000000000000815260609390931b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660018401526015830191909152603582015260550190565b6040516020818303038152906040528051906020012090565b6000806040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016114e291906121b9565b6040516020818303038152906040529050828151602083016000f5915073ffffffffffffffffffffffffffffffffffffffff821661154c576040517f27afa9fc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b6060610a7684848460006119ff565b60008080808061157381875b90611a64565b90508060e01c945067ffffffffffffffff8160a01c16935073ffffffffffffffffffffffffffffffffffffffff811692506115bb600060206115b59190612125565b8761156d565b60001c9150509193509193565b6000608083901c6fffffffffffffffffffffffffffffffff841680841061161b576040517fdfc52d7b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80846014011115611658576040517f4b72f29d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b509091015160601c92915050565b818161168973ffffffffffffffffffffffffffffffffffffffff8316868361189d565b935093915050565b600080808080806116c26116a6826020612125565b6116b1906020612125565b6116bc906014612125565b8861156d565b90508060601c955060ff8160581c16945060ff8160501c16935073ffffffffffffffffffffffffffffffffffffffff81169250611727600060206117069190612125565b611711906020612125565b61171c906014612125565b6116bc906020612125565b60001c91505091939590929450565b6040517f82b8660000000000000000000000000000000000000000000000000000000000815260ff8216600482015260009073ffffffffffffffffffffffffffffffffffffffff8416906382b8660090602401602060405180830381865afa9250505080156117c2575060408051601f3d908101601f191682019092526117bf918101906120ad565b60015b610d945750600061091f565b6040517f9169558600000000000000000000000000000000000000000000000000000000815260ff808716600483015285166024820152604481018490526064810182905269ffffffffffffffffffff8316608482015260009073ffffffffffffffffffffffffffffffffffffffff88169063916955869060a4016020604051808303816000875af1925050508015611884575060408051601f3d908101601f19168201909252611881918101906120ca565b60015b61189057506000611893565b90505b9695505050505050565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526113a89084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016111bd565b6000611955826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16611aff9092919063ffffffff16565b8051909150156113a857808060200190518101906119739190612225565b6113a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401611349565b6060611a5b73ffffffffffffffffffffffffffffffffffffffff851684604051602001611a2d929190612247565b60408051601f1981840301815291905273ffffffffffffffffffffffffffffffffffffffff87169084611b0e565b95945050505050565b6000608083901c6fffffffffffffffffffffffffffffffff8416808410611ab7576040517fdfc52d7b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80846020011115611af4576040517f4b72f29d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b509091015192915050565b6060610a768484600085611b30565b6060610a7684848460405180606001604052806029815260200161229d602991395b606082471015611bc2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401611349565b73ffffffffffffffffffffffffffffffffffffffff85163b611c40576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401611349565b6000808673ffffffffffffffffffffffffffffffffffffffff168587604051611c69919061226d565b60006040518083038185875af1925050503d8060008114611ca6576040519150601f19603f3d011682016040523d82523d6000602084013e611cab565b606091505b5091509150611cbb828286611cc6565b979650505050505050565b60608315611cd5575081610d94565b825115611ce55782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113499190612289565b73ffffffffffffffffffffffffffffffffffffffff81168114611d3b57600080fd5b50565b803563ffffffff81168114611d5257600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112611d9757600080fd5b813567ffffffffffffffff80821115611db257611db2611d57565b604051601f8301601f19908116603f01168101908282118183101715611dda57611dda611d57565b81604052838152866020858801011115611df357600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060008060008060c08789031215611e2c57600080fd5b8635611e3781611d19565b9550611e4560208801611d3e565b94506040870135611e5581611d19565b935060608701359250611e6a60808801611d3e565b915060a087013567ffffffffffffffff811115611e8657600080fd5b611e9289828a01611d86565b9150509295509295509295565b60008060408385031215611eb257600080fd5b611ebb83611d3e565b91506020830135611ecb81611d19565b809150509250929050565b60008083601f840112611ee857600080fd5b50813567ffffffffffffffff811115611f0057600080fd5b60208301915083602082850101111561105e57600080fd5b60008060008060008060808789031215611f3157600080fd5b863567ffffffffffffffff80821115611f4957600080fd5b611f558a838b01611ed6565b90985096506020890135915080821115611f6e57600080fd5b611f7a8a838b01611ed6565b9096509450849150611f8e60408a01611d3e565b93506060890135915080821115611fa457600080fd5b50611e9289828a01611d86565b600060208284031215611fc357600080fd5b610d9482611d3e565b600060208284031215611fde57600080fd5b815167ffffffffffffffff81168114610d9457600080fd5b60005b83811015612011578181015183820152602001611ff9565b50506000910152565b60008151808452612032816020860160208601611ff6565b601f01601f19169290920160200192915050565b600063ffffffff808916835267ffffffffffffffff8816602084015273ffffffffffffffffffffffffffffffffffffffff8716604084015285606084015280851660808401525060c060a08301526120a160c083018461201a565b98975050505050505050565b6000602082840312156120bf57600080fd5b8151610d9481611d19565b6000602082840312156120dc57600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b8181038181111561091f5761091f6120e3565b8082018082111561091f5761091f6120e3565b6000835161214a818460208801611ff6565b83519083019061215e818360208801611ff6565b01949350505050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b6040815260006121a6604083018688612167565b8281036020840152611cbb818587612167565b7f7f000000000000000000000000000000000000000000000000000000000000008152600082516121f1816001850160208701611ff6565b7f3d5260203df300000000000000000000000000000000000000000000000000006001939091019283015250600701919050565b60006020828403121561223757600080fd5b81518015158114610d9457600080fd5b8281526000825161225f816020850160208701611ff6565b919091016020019392505050565b6000825161227f818460208701611ff6565b9190910192915050565b602081526000610d94602083018461201a56fe416464726573733a206c6f772d6c6576656c2063616c6c20776974682076616c7565206661696c6564a2646970667358221220060b52138225159131259d6cde225506f670307a9634d5a5c057476b1bfe617f64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"54489:13358:0:-:0;;;55017:243;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;55072:32:0;;;;;;55155:41;;;-1:-1:-1;;;55155:41:0;;;;:39;;:41;;;;;;;;;;;;;;;55072:32;55155:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;55114:83:0;;;;;55221:32;;;-1:-1:-1;;;55221:32:0;;;;:30;;:32;;;;;;;;;;;;;;;55114:83;55221:32;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;55207:46;;;;-1:-1:-1;54489:13358:0;;14:148:1;-1:-1:-1;;;;;106:31:1;;96:42;;86:70;;152:1;149;142:12;86:70;14:148;:::o;167:291::-;260:6;313:2;301:9;292:7;288:23;284:32;281:52;;;329:1;326;319:12;281:52;361:9;355:16;380:48;422:5;380:48;:::i;:::-;447:5;167:291;-1:-1:-1;;;167:291:1:o;736:280::-;805:6;858:2;846:9;837:7;833:23;829:32;826:52;;;874:1;871;864:12;826:52;906:9;900:16;956:10;949:5;945:22;938:5;935:33;925:61;;982:1;979;972:12;736:280;54489:13358:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"54489:13358:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;56818:1614;;;;;;:::i;:::-;;:::i;:::-;;56246:209;;;;;;:::i;:::-;56411:35;;;56377:31;;;;:17;:31;;;;;;;;;;:71;;;;-1:-1:-1;56246:209:0;55702:415;;;;;;:::i;:::-;;:::i;54795:47::-;;;;;;;;2651:42:1;2639:55;;;2621:74;;2609:2;2594:18;54795:47:0;;;;;;;;58534:1137;;;;;;:::i;:::-;;:::i;54734:55::-;;;;;54693:35;;;;;;;;4483:10:1;4471:23;;;4453:42;;4441:2;4426:18;54693:35:0;4309:192:1;54890:51:0;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;4841:25:1;;;4829:2;4814:18;54890:51:0;4695:177:1;60098:190:0;;;;;;:::i;:::-;;:::i;56818:1614::-;57132:29;57143:9;57154:6;57132:10;:29::i;:::-;57123:38;;57171:12;57186:18;:37;;;:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;18710:78;;;57474:11;8985:3:1;8981:16;8999:66;8977:89;18710:78:0;;;8965:102:1;9104:3;9100:16;;;9118:66;9096:89;9083:11;;;9076:110;18650:29:0;9305:15:1;;;9205:66;9301:24;;;9287:12;;;9280:46;9342:12;;;9335:28;;;9397:15;;;9393:24;9379:12;;;9372:46;18710:78:0;;;;;;;;;9434:12:1;;;;18710:78:0;;;9100:16:1;;-1:-1:-1;;;57379:178:0;;57417:14;;57537:10;57379:24;:178::i;:::-;57777:36;;;57752:22;57777:36;;;;;;;;;;;57347:210;;-1:-1:-1;57827:19:0;;;57823:60;;57855:28;;;;;;;;;;;;;;57823:60;67077:18;;67025:2;67077:18;;;;;;;66995:32;;;;;66994:51;;;;57893:13;67403:17;;;67433:23;;67547:2;67534:16;;58015:57;58029:9;58048:14;58065:6;58015:13;:57::i;:::-;58082:39;:14;:39;;58135:6;58155:17;58186:14;58214:9;58237:60;58186:14;58291:5;58237:18;:60::i;:::-;58082:225;;;;;;;;;;;;;5658:25:1;;;;58082:225:0;5719:23:1;;;;5699:18;;;5692:51;5759:18;;;5752:34;;;;5834:42;5822:55;5802:18;;;5795:83;5894:19;;;5887:35;5630:19;;58082:225:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;58419:5;58322:103;58340:17;58359:5;58366:9;58377:6;58385:14;58401:16;58322:103;;;;;;;;;;;:::i;:::-;;;;;;;;57034:1398;;;;56818:1614;;;;;;:::o;55702:415::-;55786:19;55821:14;:26;;;:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;55786:64;;55860:18;55881:6;:20;;;55902:12;55916:30;:11;:28;;25933:22;;;25836:127;55916:30;55881:66;;;;;;;;;;;7664:23:1;;;;55881:66:0;;;7646:42:1;7704:18;;;7697:34;7619:18;;55881:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;55860:87;-1:-1:-1;55961:24:0;;;55957:61;;55994:24;;;;;;;;;;;;;;55957:61;67786:28;67811:3;67786:28;;;;;;;;67785:53;;;;;56028:69;;;;:26;:69;;;;;:82;;;;;;;;;;;;;;-1:-1:-1;55702:415:0:o;58534:1137::-;58830:15;58848:56;58871:14;58887:16;58848:22;:56::i;:::-;67077:18;;67025:2;67077:18;;;;;;;66995:32;58937:11;66995:32;;;66994:51;;;;58914:13;67403:17;;;67433:23;;67547:2;67534:16;;58830:74;;-1:-1:-1;59060:43:0;59077:7;;59086:9;;67534:16;59060;:43::i;:::-;59114:13;59129:14;59147:24;59163:7;59147:15;:24::i;:::-;59113:58;;;;59181:11;59288:24;59298:5;59305:6;59288:9;:24::i;:::-;59272:40;;-1:-1:-1;59272:40:0;-1:-1:-1;59421:17:0;59441:19;:7;:17;:19::i;:::-;59421:39;;59471:16;59489:17;59510:66;59526:9;59537:5;59544:6;59552:14;59568:7;59510:15;:66::i;:::-;59591:73;;;;8052:15:1;;;8034:34;;8099:2;8084:18;;8077:34;;;8147:15;;;8127:18;;;8120:43;8194:2;8179:18;;8172:34;;;59591:73:0;;8147:15:1;;-1:-1:-1;8172:34:1;;-1:-1:-1;59658:5:0;;59591:73;;;;;;;;;;7960:3:1;59591:73:0;;;58713:958;;;;;;;;58534:1137;;;;;;:::o;60098:190::-;67785:53;;;;67811:3;67786:28;;;;;67785:53;60186:7;60212:69;;;:26;:69;;;;;;;60098:190;;;;;:::o;61441:324::-;61566:38;;;;;61598:4;61566:38;;;2621:74:1;61510:20:0;;;;61566:23;;;;;;2594:18:1;;61566:38:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;61542:62;-1:-1:-1;61614:65:0;:30;;;61645:10;61665:4;61672:6;61614:30;:65::i;:::-;61704:38;;;;;61736:4;61704:38;;;2621:74:1;61745:13:0;;61704:23;;;;;;2594:18:1;;61704:38:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:54;;;;:::i;:::-;61689:69;61441:324;-1:-1:-1;;;;61441:324:0:o;20276:651::-;20428:29;17362:1;20473:29;;;;20469:65;;;20511:23;;;;;;;;;;;;;;20469:65;17464:23;17416:1;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;20548:12;:19;:42;20544:79;;20599:24;;;;;;;;;;;;;;20544:79;20637:30;;;;:57;;;;-1:-1:-1;20671:18:0;;:23;;20637:57;20633:94;;;20703:24;;;;;;;;;;;;;;20633:94;20741:30;;;17362:1;20741:30;:74;;;;-1:-1:-1;17464:23:0;17416:1;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;17464:23;17416:1;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;17756:23;;17777:2;17756:23;:::i;:::-;17832:26;;17856:2;17832:26;:::i;:::-;17910:41;;;;:::i;:::-;20775:11;:18;:40;;20741:74;20737:111;;;20824:24;;;;;;;;;;;;;;20737:111;20894:12;20908:11;20877:43;;;;;;;;;:::i;:::-;;;;;;;;;;;;;20858:62;;20276:651;;;;;:::o;60941:448::-;61081:47;;;;;61113:4;61081:47;;;10319:34:1;61081:23:0;10389:15:1;;;10369:18;;;10362:43;61061:17:0;;61081:23;;;;;;10231:18:1;;61081:47:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;61061:67;;61154:6;61142:9;:18;61138:245;;;61252:14;;61248:57;;61268:37;:25;;;61294:7;61303:1;61268:25;:37::i;:::-;61319:53;:25;;;61345:7;61354:17;61319:25;:53::i;:::-;61051:338;60941:448;;;:::o;66485:172::-;66572:7;66598:52;:33;:26;;;66625:5;66598:26;:33::i;:::-;:50;;;25836:127;66598:52;66591:59;66485:172;-1:-1:-1;;;66485:172:0:o;21015:596::-;21104:7;17362:1;21127:29;;;;21123:65;;;21165:23;;;;;;;;;;;;;;21123:65;21202:30;;;;:71;;;;-1:-1:-1;17464:23:0;17416:1;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;21236:7;:14;:37;;21202:71;21198:133;;;21296:24;;;;;;;;;;;;;;21198:133;21344:30;;;17362:1;21344:30;:71;;;;-1:-1:-1;17464:23:0;17416:1;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;17756:23;;17777:2;17756:23;:::i;:::-;17832:26;;17856:2;17832:26;:::i;:::-;21378:7;:14;:37;;21344:71;21340:133;;;21438:24;;;;;;;;;;;;;;21340:133;12617:10;;12579:4;12570:14;;12872:3;12865:10;12864:18;21569:33;12108:782;61866:764;62109:17;62129:33;62156:5;62129:26;:33::i;:::-;62109:53;;62223:20;62269:43;;;62314:7;;62323:9;;62246:87;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;62246:87:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;62564:59:0;:21;;;62594:18;62246:87;62564:21;:59::i;:::-;;61996:634;;61866:764;;;;;:::o;65542:447::-;65607:13;65622:14;65648:19;65677:23;65754:20;:7;:18;:20::i;:::-;67785:53;;;;67811:3;67786:28;;;;;67785:53;65844:73;;;;:26;:73;;;;;;;;-1:-1:-1;65710:64:0;-1:-1:-1;65710:64:0;;-1:-1:-1;65710:64:0;;-1:-1:-1;65844:73:0;;-1:-1:-1;65927:55:0;;65959:23;;;;;;;;;;;;;;65927:55;65638:351;;65542:447;;;:::o;60679:184::-;60846:6;60747:22;60679:184;;;;;;:::o;23666:139::-;23725:7;23751:47;17464:23;23725:7;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;23751:7;:29;;:47::i;62826:1302::-;63005:16;;63056:41;;;63052:124;;63120:45;63140:9;63151:5;63158:6;63120:19;:45::i;:::-;63113:52;;;;;;63052:124;63334:12;63348:20;63370:18;63390:15;63407:20;63431:33;:7;:31;:33::i;:::-;63333:131;;;;;;;;;;63485:32;63498:4;63504:12;63485;:32::i;:::-;63474:43;-1:-1:-1;63601:22:0;;;63597:105;;63646:45;63666:9;63677:5;63684:6;63646:19;:45::i;:::-;63639:52;;;;;;;;;;;63597:105;63711:34;63725:5;63732:4;63738:6;63711:13;:34::i;:::-;63767:76;63776:4;63782:14;63798:12;63812:6;63820:8;63830:12;63767:8;:76::i;:::-;63755:88;;63911:9;63924:1;63911:14;63907:97;;63948:45;63968:9;63979:5;63986:6;63948:19;:45::i;63907:97::-;64070:51;:29;;;64100:9;64111;64070:29;:51::i;:::-;63042:1086;;;;;62826:1302;;;;;;;;;:::o;51484:241::-;51649:68;;11394:42:1;11463:15;;;51649:68:0;;;11445:34:1;11515:15;;11495:18;;;11488:43;11547:18;;;11540:34;;;51622:96:0;;51642:5;;51672:27;;11357:18:1;;51649:68:0;;;;-1:-1:-1;;51649:68:0;;;;;;;;;;;;;;;;;;;;;;;;;;;51622:19;:96::i;51985:603::-;52340:10;;;52339:62;;-1:-1:-1;52356:39:0;;;;;52380:4;52356:39;;;10319:34:1;52356:15:0;10389::1;;;10369:18;;;10362:43;52356:15:0;;;;;10231:18:1;;52356:39:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:44;52339:62;52318:163;;;;;;;11787:2:1;52318:163:0;;;11769:21:1;11826:2;11806:18;;;11799:30;11865:34;11845:18;;;11838:62;11936:24;11916:18;;;11909:52;11978:19;;52318:163:0;;;;;;;;;52518:62;;12212:42:1;12200:55;;52518:62:0;;;12182:74:1;12272:18;;;12265:34;;;52491:90:0;;52511:5;;52541:22;;12155:18:1;;52518:62:0;12008:297:1;52491:90:0;51985:603;;;:::o;47767:209::-;47846:7;47872:97;47908:8;47918:4;44379:18;;;;;;;;;;;;;;;;;44353:69;;;;;;;;:::i;:::-;;;;;;;;;;;;;44592:30;;;;;;47882:67;;;;;;;;;13322:66:1;13310:79;;13426:2;13422:15;;;;13439:66;13418:88;13414:1;13405:11;;13398:109;13532:2;13523:12;;13516:28;;;;13569:2;13560:12;;13553:28;13606:2;13597:12;;13024:591;47882:67:0;;;;;;;;;;;;;47872:78;;;;;;26114:3;26002:125;44908:799;44956:17;45177:21;44379:18;;;;;;;;;;;;;;;;;44353:69;;;;;;;;:::i;:::-;;;;;;;;;;;;;45177:43;;45530:4;45519:8;45513:15;45506:4;45496:8;45492:19;45489:1;45481:54;45468:67;-1:-1:-1;45617:23:0;;;45613:88;;45663:27;;;;;;;;;;;;;;45613:88;44975:732;44908:799;;;:::o;46140:280::-;46266:23;46362:51;46383:9;46394:6;46402:7;46411:1;46362:20;:51::i;22463:1014::-;22560:19;;;;;22710:49;22560:19;22710:7;:16;:29;;:49::i;:::-;22695:64;;22954:4;22949:3;22945:14;22929:30;;23121:18;23114:4;23109:3;23105:14;23101:39;23092:48;;23294:42;23288:4;23284:53;23265:72;;23425:44;17416:1;17485:2;17464:23;;;;:::i;:::-;23425:7;:16;21698:132;23425:44;23417:53;;23408:62;;22685:792;22463:1014;;;;;:::o;13683:771::-;13759:13;14972:3;14946:29;;;15059:37;;;13863:12;;;13859:42;;13884:17;;;;;;;;;;;;;;13859:42;13998:3;13985:5;13993:2;13985:10;:16;13981:43;;;14010:14;;;;;;;;;;;;;;13981:43;-1:-1:-1;14421:15:0;;;14415:22;14411:2;14407:31;;13683:771;-1:-1:-1;;13683:771:0:o;64216:280::-;64401:5;64428:6;64444:45;:26;;;64471:9;64428:6;64444:26;:45::i;:::-;64216:280;;;;;;:::o;24592:1183::-;24689:12;;;;;;24870:49;17464:23;24689:12;17485:2;17464:23;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;24870:7;:16;21698:132;24870:49;24855:64;;25097:4;25093:2;25089:13;25081:21;;25267:4;25260;25256:2;25252:13;25248:24;25230:42;;25433:4;25426;25422:2;25418:13;25414:24;25398:40;;25578:42;25572:4;25568:53;25556:65;;25715:52;17416:1;17485:2;17464:23;;;;:::i;:::-;17537:18;;17553:2;17537:18;:::i;:::-;17608:21;;17627:2;17608:21;:::i;:::-;17756:23;;17777:2;17756:23;:::i;25715:52::-;25707:61;;25692:76;;24845:930;24592:1183;;;;;;;:::o;66118:300::-;66224:39;;;;;13792:4:1;13780:17;;66224:39:0;;;13762:36:1;66195:13:0;;66224:27;;;;;;13735:18:1;;66224:39:0;;;;;;;;;;;;;;;;;;-1:-1:-1;66224:39:0;;;;;;;;-1:-1:-1;;66224:39:0;;;;;;;;;;;;:::i;:::-;;;66220:192;;-1:-1:-1;66399:1:0;66220:192;;64634:510;64868:85;;;;;14089:4:1;14077:17;;;64868:85:0;;;14059:36:1;14131:17;;14111:18;;;14104:45;14165:18;;;14158:34;;;14208:18;;;14201:34;;;14284:22;14272:35;;14251:19;;;14244:64;64835:17:0;;64868:23;;;;;;14031:19:1;;64868:85:0;;;;;;;;;;;;;;;;;;;-1:-1:-1;64868:85:0;;;;;;;;-1:-1:-1;;64868:85:0;;;;;;;;;;;;:::i;:::-;;;64864:274;;-1:-1:-1;65126:1:0;64864:274;;;65031:10;-1:-1:-1;64864:274:0;64634:510;;;;;;;;:::o;51273:205::-;51412:58;;12212:42:1;12200:55;;51412:58:0;;;12182:74:1;12272:18;;;12265:34;;;51385:86:0;;51405:5;;51435:23;;12155:18:1;;51412:58:0;12008:297:1;53779:706:0;54198:23;54224:69;54252:4;54224:69;;;;;;;;;;;;;;;;;54232:5;54224:27;;;;:69;;;;;:::i;:::-;54307:17;;54198:95;;-1:-1:-1;54307:21:0;54303:176;;54402:10;54391:30;;;;;;;;;;;;:::i;:::-;54383:85;;;;;;;14803:2:1;54383:85:0;;;14785:21:1;14842:2;14822:18;;;14815:30;14881:34;14861:18;;;14854:62;14952:12;14932:18;;;14925:40;14982:19;;54383:85:0;14601:406:1;46948:481:0;47106:23;47330:92;47379:23;;;47406:7;47362:52;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;47362:52:0;;;;;;;;;47330:31;;;;47416:5;47330:31;:92::i;:::-;47317:105;46948:481;-1:-1:-1;;;;;46948:481:0:o;12991:553::-;13067:13;14972:3;14946:29;;;15059:37;;;13171:12;;;13167:42;;13192:17;;;;;;;;;;;;;;13167:42;13306:3;13293:5;13301:2;13293:10;:16;13289:43;;;13318:14;;;;;;;;;;;;;;13289:43;-1:-1:-1;13512:15:0;;;13506:22;;12991:553;-1:-1:-1;;12991:553:0:o;29935:223::-;30068:12;30099:52;30121:6;30129:4;30135:1;30138:12;30099:21;:52::i;30520:254::-;30649:12;30680:87;30702:6;30710:4;30716:5;30680:87;;;;;;;;;;;;;;;;;31022:499;31187:12;31244:5;31219:21;:30;;31211:81;;;;;;;15578:2:1;31211:81:0;;;15560:21:1;15617:2;15597:18;;;15590:30;15656:34;15636:18;;;15629:62;15727:8;15707:18;;;15700:36;15753:19;;31211:81:0;15376:402:1;31211:81:0;27539:19;;;;31302:60;;;;;;;15985:2:1;31302:60:0;;;15967:21:1;16024:2;16004:18;;;15997:30;16063:31;16043:18;;;16036:59;16112:18;;31302:60:0;15783:353:1;31302:60:0;31374:12;31388:23;31415:6;:11;;31434:5;31441:4;31415:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;31373:73;;;;31463:51;31480:7;31489:10;31501:12;31463:16;:51::i;:::-;31456:58;31022:499;-1:-1:-1;;;;;;;31022:499:0:o;33635:692::-;33781:12;33809:7;33805:516;;;-1:-1:-1;33839:10:0;33832:17;;33805:516;33950:17;;:21;33946:365;;34144:10;34138:17;34204:15;34191:10;34187:2;34183:19;34176:44;33946:365;34283:12;34276:20;;;;;;;;;;;:::i;14:154:1:-;100:42;93:5;89:54;82:5;79:65;69:93;;158:1;155;148:12;69:93;14:154;:::o;173:163::-;240:20;;300:10;289:22;;279:33;;269:61;;326:1;323;316:12;269:61;173:163;;;:::o;341:184::-;393:77;390:1;383:88;490:4;487:1;480:15;514:4;511:1;504:15;530:777;572:5;625:3;618:4;610:6;606:17;602:27;592:55;;643:1;640;633:12;592:55;679:6;666:20;705:18;742:2;738;735:10;732:36;;;748:18;;:::i;:::-;882:2;876:9;944:4;936:13;;-1:-1:-1;;932:22:1;;;956:2;928:31;924:40;912:53;;;980:18;;;1000:22;;;977:46;974:72;;;1026:18;;:::i;:::-;1066:10;1062:2;1055:22;1101:2;1093:6;1086:18;1147:3;1140:4;1135:2;1127:6;1123:15;1119:26;1116:35;1113:55;;;1164:1;1161;1154:12;1113:55;1228:2;1221:4;1213:6;1209:17;1202:4;1194:6;1190:17;1177:54;1275:1;1268:4;1263:2;1255:6;1251:15;1247:26;1240:37;1295:6;1286:15;;;;;;530:777;;;;:::o;1312:811::-;1423:6;1431;1439;1447;1455;1463;1516:3;1504:9;1495:7;1491:23;1487:33;1484:53;;;1533:1;1530;1523:12;1484:53;1572:9;1559:23;1591:31;1616:5;1591:31;:::i;:::-;1641:5;-1:-1:-1;1665:37:1;1698:2;1683:18;;1665:37;:::i;:::-;1655:47;;1754:2;1743:9;1739:18;1726:32;1767:33;1792:7;1767:33;:::i;:::-;1819:7;-1:-1:-1;1873:2:1;1858:18;;1845:32;;-1:-1:-1;1896:38:1;1929:3;1914:19;;1896:38;:::i;:::-;1886:48;;1985:3;1974:9;1970:19;1957:33;2013:18;2005:6;2002:30;1999:50;;;2045:1;2042;2035:12;1999:50;2068:49;2109:7;2100:6;2089:9;2085:22;2068:49;:::i;:::-;2058:59;;;1312:811;;;;;;;;:::o;2128:319::-;2195:6;2203;2256:2;2244:9;2235:7;2231:23;2227:32;2224:52;;;2272:1;2269;2262:12;2224:52;2295:28;2313:9;2295:28;:::i;:::-;2285:38;;2373:2;2362:9;2358:18;2345:32;2386:31;2411:5;2386:31;:::i;:::-;2436:5;2426:15;;;2128:319;;;;;:::o;2706:347::-;2757:8;2767:6;2821:3;2814:4;2806:6;2802:17;2798:27;2788:55;;2839:1;2836;2829:12;2788:55;-1:-1:-1;2862:20:1;;2905:18;2894:30;;2891:50;;;2937:1;2934;2927:12;2891:50;2974:4;2966:6;2962:17;2950:29;;3026:3;3019:4;3010:6;3002;2998:19;2994:30;2991:39;2988:59;;;3043:1;3040;3033:12;3058:988;3174:6;3182;3190;3198;3206;3214;3267:3;3255:9;3246:7;3242:23;3238:33;3235:53;;;3284:1;3281;3274:12;3235:53;3324:9;3311:23;3353:18;3394:2;3386:6;3383:14;3380:34;;;3410:1;3407;3400:12;3380:34;3449:58;3499:7;3490:6;3479:9;3475:22;3449:58;:::i;:::-;3526:8;;-1:-1:-1;3423:84:1;-1:-1:-1;3614:2:1;3599:18;;3586:32;;-1:-1:-1;3630:16:1;;;3627:36;;;3659:1;3656;3649:12;3627:36;3698:60;3750:7;3739:8;3728:9;3724:24;3698:60;:::i;:::-;3777:8;;-1:-1:-1;3672:86:1;-1:-1:-1;3672:86:1;;-1:-1:-1;3831:37:1;3864:2;3849:18;;3831:37;:::i;:::-;3821:47;;3921:2;3910:9;3906:18;3893:32;3877:48;;3950:2;3940:8;3937:16;3934:36;;;3966:1;3963;3956:12;3934:36;;3989:51;4032:7;4021:8;4010:9;4006:24;3989:51;:::i;4506:184::-;4564:6;4617:2;4605:9;4596:7;4592:23;4588:32;4585:52;;;4633:1;4630;4623:12;4585:52;4656:28;4674:9;4656:28;:::i;5108:288::-;5177:6;5230:2;5218:9;5209:7;5205:23;5201:32;5198:52;;;5246:1;5243;5236:12;5198:52;5278:9;5272:16;5328:18;5321:5;5317:30;5310:5;5307:41;5297:69;;5362:1;5359;5352:12;5933:250;6018:1;6028:113;6042:6;6039:1;6036:13;6028:113;;;6118:11;;;6112:18;6099:11;;;6092:39;6064:2;6057:10;6028:113;;;-1:-1:-1;;6175:1:1;6157:16;;6150:27;5933:250::o;6188:329::-;6229:3;6267:5;6261:12;6294:6;6289:3;6282:19;6310:76;6379:6;6372:4;6367:3;6363:14;6356:4;6349:5;6345:16;6310:76;:::i;:::-;6431:2;6419:15;-1:-1:-1;;6415:88:1;6406:98;;;;6506:4;6402:109;;6188:329;-1:-1:-1;;6188:329:1:o;6522:691::-;6766:4;6795:10;6844:2;6836:6;6832:15;6821:9;6814:34;6896:18;6888:6;6884:31;6879:2;6868:9;6864:18;6857:59;6964:42;6956:6;6952:55;6947:2;6936:9;6932:18;6925:83;7044:6;7039:2;7028:9;7024:18;7017:34;7100:2;7092:6;7088:15;7082:3;7071:9;7067:19;7060:44;;7141:3;7135;7124:9;7120:19;7113:32;7162:45;7202:3;7191:9;7187:19;7179:6;7162:45;:::i;:::-;7154:53;6522:691;-1:-1:-1;;;;;;;;6522:691:1:o;7218:251::-;7288:6;7341:2;7329:9;7320:7;7316:23;7312:32;7309:52;;;7357:1;7354;7347:12;7309:52;7389:9;7383:16;7408:31;7433:5;7408:31;:::i;8217:184::-;8287:6;8340:2;8328:9;8319:7;8315:23;8311:32;8308:52;;;8356:1;8353;8346:12;8308:52;-1:-1:-1;8379:16:1;;8217:184;-1:-1:-1;8217:184:1:o;8406:::-;8458:77;8455:1;8448:88;8555:4;8552:1;8545:15;8579:4;8576:1;8569:15;8595:128;8662:9;;;8683:11;;;8680:37;;;8697:18;;:::i;9457:125::-;9522:9;;;9543:10;;;9540:36;;;9556:18;;:::i;9587:492::-;9762:3;9800:6;9794:13;9816:66;9875:6;9870:3;9863:4;9855:6;9851:17;9816:66;:::i;:::-;9945:13;;9904:16;;;;9967:70;9945:13;9904:16;10014:4;10002:17;;9967:70;:::i;:::-;10053:20;;9587:492;-1:-1:-1;;;;9587:492:1:o;10416:325::-;10504:6;10499:3;10492:19;10556:6;10549:5;10542:4;10537:3;10533:14;10520:43;;10608:1;10601:4;10592:6;10587:3;10583:16;10579:27;10572:38;10474:3;10730:4;-1:-1:-1;;10655:2:1;10647:6;10643:15;10639:88;10634:3;10630:98;10626:109;10619:116;;10416:325;;;;:::o;10746:431::-;10959:2;10948:9;10941:21;10922:4;10985:61;11042:2;11031:9;11027:18;11019:6;11011;10985:61;:::i;:::-;11094:9;11086:6;11082:22;11077:2;11066:9;11062:18;11055:50;11122:49;11164:6;11156;11148;11122:49;:::i;12310:709::-;12671:66;12666:3;12659:79;12641:3;12767:6;12761:13;12783:74;12850:6;12846:1;12841:3;12837:11;12830:4;12822:6;12818:17;12783:74;:::i;:::-;12920:66;12916:1;12876:16;;;;12908:10;;;12901:86;-1:-1:-1;13011:1:1;13003:10;;12310:709;-1:-1:-1;12310:709:1:o;14319:277::-;14386:6;14439:2;14427:9;14418:7;14414:23;14410:32;14407:52;;;14455:1;14452;14445:12;14407:52;14487:9;14481:16;14540:5;14533:13;14526:21;14519:5;14516:32;14506:60;;14562:1;14559;14552:12;15012:359;15199:6;15194:3;15187:19;15169:3;15235:6;15229:13;15251:73;15317:6;15312:2;15307:3;15303:12;15298:2;15290:6;15286:15;15251:73;:::i;:::-;15344:16;;;;15362:2;15340:25;;15012:359;-1:-1:-1;;;15012:359:1:o;16141:287::-;16270:3;16308:6;16302:13;16324:66;16383:6;16378:3;16371:4;16363:6;16359:17;16324:66;:::i;:::-;16406:16;;;;;16141:287;-1:-1:-1;;16141:287:1:o;16433:219::-;16582:2;16571:9;16564:21;16545:4;16602:44;16642:2;16631:9;16627:18;16619:6;16602:44;:::i","abiDefinition":[{"inputs":[{"internalType":"contract ITokenMessenger","name":"tokenMessenger_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"ForwarderDeploymentFailed","type":"error"},{"inputs":[],"name":"IncorrectRequestLength","type":"error"},{"inputs":[],"name":"IndexOutOrRange","type":"error"},{"inputs":[],"name":"LocalCCTPTokenNotFound","type":"error"},{"inputs":[],"name":"RemoteCCTPDeploymentNotSet","type":"error"},{"inputs":[],"name":"RemoteCCTPTokenNotSet","type":"error"},{"inputs":[],"name":"SliceOverrun","type":"error"},{"inputs":[],"name":"UnknownRequestVersion","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"address","name":"mintToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"kappa","type":"bytes32"}],"name":"CircleRequestFulfilled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint32","name":"requestVersion","type":"uint32"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"kappa","type":"bytes32"}],"name":"CircleRequestSent","type":"event"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"remoteToken","type":"address"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"messageTransmitter","outputs":[{"internalType":"contract IMessageTransmitter","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"formattedRequest","type":"bytes"}],"name":"receiveCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"","type":"uint32"}],"name":"remoteSynapseCCTP","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"swapParams","type":"bytes"}],"name":"sendCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"remoteToken","type":"address"}],"name":"setLocalToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"remoteSynapseCCTP_","type":"address"}],"name":"setRemoteSynapseCCTP","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"tokenMessenger","outputs":[{"internalType":"contract ITokenMessenger","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"events":{"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"notice":"Emitted when a Circle token is received with an attached action request."},"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)":{"notice":"Emitted when a Circle token is sent with an attached action request."}},"kind":"user","methods":{"getLocalToken(uint32,address)":{"notice":"Get the local token associated with the given remote domain and token."},"receiveCircleToken(bytes,bytes,uint32,bytes)":{"notice":"Receive  Circle token supported by CCTP with the request for the action to take."},"sendCircleToken(address,uint32,address,uint256,uint32,bytes)":{"notice":"Send a Circle token supported by CCTP to a given domain with the request for the action to take on the destination domain."},"setLocalToken(uint32,address)":{"notice":"Sets the local token associated with the given remote domain and token."},"setRemoteSynapseCCTP(uint32,address)":{"notice":"Sets the remote deployment of SynapseCCTP for the given remote domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveCircleToken(bytes,bytes,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this domain.","params":{"formattedRequest":"Formatted request for the action to take on this domain","message":"Message raw bytes emitted by CCTP MessageTransmitter on origin domain","requestVersion":"Version of the request format","signature":"Circle's attestation for the message obtained from Circle's API"}},"sendCircleToken(address,uint32,address,uint256,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination domain.","params":{"amount":"Amount of tokens to burn","burnToken":"Address of Circle token to burn","destinationDomain":"Domain of destination chain","recipient":"Recipient of the tokens on destination domain","requestVersion":"Version of the request format","swapParams":"Swap parameters for the action to take on the destination domain (could be empty)"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"tokenMessenger_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ForwarderDeploymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectRequestLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexOutOrRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LocalCCTPTokenNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RemoteCCTPDeploymentNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RemoteCCTPTokenNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOverrun\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownRequestVersion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"kappa\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"kappa\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"remoteToken\",\"type\":\"address\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageTransmitter\",\"outputs\":[{\"internalType\":\"contract IMessageTransmitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"}],\"name\":\"receiveCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"remoteSynapseCCTP\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"swapParams\",\"type\":\"bytes\"}],\"name\":\"sendCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"remoteToken\",\"type\":\"address\"}],\"name\":\"setLocalToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"remoteSynapseCCTP_\",\"type\":\"address\"}],\"name\":\"setRemoteSynapseCCTP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMessenger\",\"outputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this domain.\",\"params\":{\"formattedRequest\":\"Formatted request for the action to take on this domain\",\"message\":\"Message raw bytes emitted by CCTP MessageTransmitter on origin domain\",\"requestVersion\":\"Version of the request format\",\"signature\":\"Circle's attestation for the message obtained from Circle's API\"}},\"sendCircleToken(address,uint32,address,uint256,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination domain.\",\"params\":{\"amount\":\"Amount of tokens to burn\",\"burnToken\":\"Address of Circle token to burn\",\"destinationDomain\":\"Domain of destination chain\",\"recipient\":\"Recipient of the tokens on destination domain\",\"requestVersion\":\"Version of the request format\",\"swapParams\":\"Swap parameters for the action to take on the destination domain (could be empty)\"}}},\"version\":1},\"userdoc\":{\"events\":{\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"notice\":\"Emitted when a Circle token is received with an attached action request.\"},\"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)\":{\"notice\":\"Emitted when a Circle token is sent with an attached action request.\"}},\"kind\":\"user\",\"methods\":{\"getLocalToken(uint32,address)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"notice\":\"Receive  Circle token supported by CCTP with the request for the action to take.\"},\"sendCircleToken(address,uint32,address,uint256,uint32,bytes)\":{\"notice\":\"Send a Circle token supported by CCTP to a given domain with the request for the action to take on the destination domain.\"},\"setLocalToken(uint32,address)\":{\"notice\":\"Sets the local token associated with the given remote domain and token.\"},\"setRemoteSynapseCCTP(uint32,address)\":{\"notice\":\"Sets the remote deployment of SynapseCCTP for the given remote domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTP\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{"getLocalToken(uint32,address)":"f879a41a","localDomain()":"8d3638f4","messageTransmitter()":"7b04c181","receiveCircleToken(bytes,bytes,uint32,bytes)":"4a5ae51d","remoteSynapseCCTP(uint32)":"e8eb1df0","sendCircleToken(address,uint32,address,uint256,uint32,bytes)":"08617500","setLocalToken(uint32,address)":"393e5b60","setRemoteSynapseCCTP(uint32,address)":"242fdf1d","tokenMessenger()":"46117830"}},"solidity/SynapseCCTP.sol:SynapseCCTPEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"address","name":"mintToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"kappa","type":"bytes32"}],"name":"CircleRequestFulfilled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint32","name":"requestVersion","type":"uint32"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"kappa","type":"bytes32"}],"name":"CircleRequestSent","type":"event"}],"userDoc":{"events":{"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"notice":"Emitted when a Circle token is received with an attached action request."},"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)":{"notice":"Emitted when a Circle token is sent with an attached action request."}},"kind":"user","methods":{},"version":1},"developerDoc":{"events":{"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"params":{"amount":"Amount of tokens received by recipient","fee":"Fee paid for fulfilling the request, in minted tokens","kappa":"Unique identifier of the request","mintToken":"Address of the minted Circle token","recipient":"End recipient of the tokens on this domain","token":"Address of token that recipient received"}},"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)":{"details":"To fulfill the request, the validator needs to fetch `message` from `MessageSent` event emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API. All this data will need to be presented to SynapseCCTP on the destination domain.","params":{"amount":"Amount of Circle tokens burnt","destinationDomain":"Domain of destination chain","kappa":"Unique identifier of the request","nonce":"Nonce of the CCTP message on origin domain","request":"Request for the action to take on the destination domain","requestVersion":"Version of the request format","token":"Address of Circle token that was burnt"}}},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"kappa\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"kappa\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestSent\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"params\":{\"amount\":\"Amount of tokens received by recipient\",\"fee\":\"Fee paid for fulfilling the request, in minted tokens\",\"kappa\":\"Unique identifier of the request\",\"mintToken\":\"Address of the minted Circle token\",\"recipient\":\"End recipient of the tokens on this domain\",\"token\":\"Address of token that recipient received\"}},\"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)\":{\"details\":\"To fulfill the request, the validator needs to fetch `message` from `MessageSent` event emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API. All this data will need to be presented to SynapseCCTP on the destination domain.\",\"params\":{\"amount\":\"Amount of Circle tokens burnt\",\"destinationDomain\":\"Domain of destination chain\",\"kappa\":\"Unique identifier of the request\",\"nonce\":\"Nonce of the CCTP message on origin domain\",\"request\":\"Request for the action to take on the destination domain\",\"requestVersion\":\"Version of the request format\",\"token\":\"Address of Circle token that was burnt\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"notice\":\"Emitted when a Circle token is received with an attached action request.\"},\"CircleRequestSent(uint32,uint64,address,uint256,uint32,bytes,bytes32)\":{\"notice\":\"Emitted when a Circle token is sent with an attached action request.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTPEvents\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122079aba74b1e3a52eb29a69ba387a21d32a46e3ee6d6952e6e0bd15101d09805ad64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122079aba74b1e3a52eb29a69ba387a21d32a46e3ee6d6952e6e0bd15101d09805ad64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror IndexOutOrRange();\nerror SliceOverrun();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror LocalCCTPTokenNotFound();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// All this data will need to be presented to SynapseCCTP on the destination domain.\n    /// @param destinationDomain    Domain of destination chain\n    /// @param nonce                Nonce of the CCTP message on origin domain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param request              Request for the action to take on the destination domain\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestSent(\n        uint32 destinationDomain,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes request,\n        bytes32 indexed kappa\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this domain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param kappa                Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed kappa\n    );\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given domain\n    /// with the request for the action to take on the destination domain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination domain.\n    /// @param recipient            Recipient of the tokens on destination domain\n    /// @param destinationDomain    Domain of destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination domain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this domain.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin domain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this domain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// `BytesArray` is a custom type for storing a memory reference to a bytes array.\ntype BytesArray is uint256;\n\nusing SlicerLib for BytesArray global;\n\n/// Library for slicing bytes arrays.\n/// # BytesArray stack layout (from highest bits to lowest)\n///\n/// | Position   | Field | Type    | Bytes | Description                              |\n/// | ---------- | ----- | ------- | ----- | ---------------------------------------- |\n/// | (032..016] | loc   | uint128 | 16    | Memory address of underlying bytes array |\n/// | (016..000] | len   | uint128 | 16    | Length of underlying bytes array         |\nlibrary SlicerLib {\n    /// @notice Wrap a bytes array into a `BytesArray` custom type.\n    function wrapBytesArray(bytes memory arr) internal pure returns (BytesArray) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        uint256 loc;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We add 0x20 to get the locations where the array data starts\n            loc := add(arr, 0x20)\n        }\n        uint256 len = arr.length;\n        // There is no scenario where loc or len would overflow uint128, so we omit this check.\n        // We use the highest 128 bits to encode the location and the lowest 128 bits to encode the length.\n        return BytesArray.wrap((loc \u003c\u003c 128) | len);\n    }\n\n    /// @notice Slices 32 bytes from the underlying bytes array starting from the given index.\n    function sliceBytes32(BytesArray arr, uint256 index) internal pure returns (bytes32 slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+32 never overflows\n            if (index + 32 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // We need to load 32 bytes starting from loc + index\n            slice := mload(add(loc, index))\n        }\n    }\n\n    /// @notice Slices 20 bytes from the underlying bytes array starting from the given index,\n    /// and returns it as an address.\n    function sliceAddress(BytesArray arr, uint256 index) internal pure returns (address slice) {\n        (uint256 loc, uint256 len) = _unwrap(arr);\n        unchecked {\n            if (index \u003e= len) revert IndexOutOrRange();\n            // len fits into uint128, so index+20 never overflows\n            if (index + 20 \u003e len) revert SliceOverrun();\n        }\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To slice the address we need to do two steps:\n            // 1. Load 32 bytes starting from loc + index: this gets the address in the highest 20 bytes\n            // 2. Shift the result to the right by 12 bytes (96 bits): this clears the dirty lowest 12 bytes\n            slice := shr(96, mload(add(loc, index)))\n        }\n    }\n\n    // ══════════════════════════════════════════════ PRIVATE HELPERS ══════════════════════════════════════════════════\n\n    function _unwrap(BytesArray arr) private pure returns (uint256 loc, uint256 len) {\n        // loc is stored in the highest 16 bytes of the underlying uint256\n        loc = BytesArray.unwrap(arr) \u003e\u003e 128;\n        // len is stored in the lowest 16 bytes of the underlying uint256\n        len = uint128(BytesArray.unwrap(arr));\n    }\n}\n\ntype Request is uint256;\n\nusing RequestLib for Request global;\n\n/// # Memory layout of common Request fields for versions [REQUEST_BASE, ...)\n/// \u003e - (originDomain, nonce, originBurnToken) are optimized for storage in a single slot.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [000..004) | originDomain    | uint32  | 4     | Domain of the origin chain                         |\n/// | [004..012) | nonce           | uint64  | 8     | Nonce of the CCTP message on origin domain         |\n/// | [012..032) | originBurnToken | address | 20    | Circle token that was burned on origin domain      |\n/// | [032..064) | amount          | uint256 | 32    | Amount of tokens to burn                           |\n/// | [064..084) | recipient       | address | 20    | Recipient of the tokens on destination domain      |\n///\n/// # Memory layout of common Request fields for versions [REQUEST_SWAP, ...)\n/// \u003e - (pool, tokenIndexFrom, tokenIndexTo, deadline) are optimized for storage in a single slot.\n/// \u003e - deadline is stored as uint80, which is enough to store timestamps until year 3*10^16.\n/// \u003e - If a swap fails due to deadline or minAmountOut check, the recipient will receive the minted Circle token.\n///\n/// | Position   | Field           | Type    | Bytes | Description                                        |\n/// | ---------- | --------------- | ------- | ----- | -------------------------------------------------- |\n/// | [084..104) | pool            | address | 20    | Liquidity pool for swapping Circle token           |\n/// | [104..105) | tokenIndexFrom  | uint8   | 1     | Index of the minted Circle token in the pool       |\n/// | [105..106) | tokenIndexTo    | uint8   | 1     | Index of the final token in the pool               |\n/// | [106..116) | deadline        | uint80  | 10    | Latest timestamp to execute the swap               |\n/// | [116..148) | minAmountOut    | uint256 | 32    | Minimum amount of tokens to receive from the swap  |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    uint256 private constant OFFSET_ORIGIN_DATA = 0;\n    uint256 private constant OFFSET_AMOUNT = OFFSET_ORIGIN_DATA + 32;\n    uint256 private constant OFFSET_RECIPIENT = OFFSET_AMOUNT + 32;\n    uint256 private constant REQUEST_BASE_LENGTH = OFFSET_RECIPIENT + 20;\n\n    uint256 private constant OFFSET_SWAP_PARAMS = REQUEST_BASE_LENGTH;\n    uint256 private constant OFFSET_MIN_AMOUNT_OUT = OFFSET_SWAP_PARAMS + 32;\n    uint256 private constant REQUEST_SWAP_LENGTH = OFFSET_MIN_AMOUNT_OUT + 32;\n    uint256 private constant SWAP_PARAMS_LENGTH = REQUEST_SWAP_LENGTH - REQUEST_BASE_LENGTH;\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain_        Domain of the origin chain\n    /// @param nonce_               Nonce of the CCTP message on origin domain\n    /// @param originBurnToken_     Circle token that was burned on origin domain\n    /// @param amount_              Amount of tokens to burn\n    /// @param recipient_           Recipient of the tokens on destination domain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain_,\n        uint64 nonce_,\n        address originBurnToken_,\n        uint256 amount_,\n        address recipient_\n    ) internal pure returns (bytes memory formattedRequest) {\n        formattedRequest = abi.encodePacked(originDomain_, nonce_, originBurnToken_, amount_, recipient_);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param pool_                Liquidity pool for swapping Circle token\n    /// @param tokenIndexFrom_      Index of the minted Circle token in the pool\n    /// @param tokenIndexTo_        Index of the final token in the pool\n    /// @param deadline_            Latest timestamp to execute the swap\n    /// @param minAmountOut_        Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        address pool_,\n        uint8 tokenIndexFrom_,\n        uint8 tokenIndexTo_,\n        uint80 deadline_,\n        uint256 minAmountOut_\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        formattedSwapParams = abi.encodePacked(pool_, tokenIndexFrom_, tokenIndexTo_, deadline_, minAmountOut_);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest_         Formatted base request\n    /// @param swapParams_          Formatted swap parameters\n    /// @return formattedRequest    Properly formatted swap request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest_,\n        bytes memory swapParams_\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (baseRequest_.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 swapParams_.length != 0) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 swapParams_.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        formattedRequest = abi.encodePacked(baseRequest_, swapParams_);\n    }\n\n    /// @notice Wraps the memory representation of a Request into a Request type.\n    function wrapRequest(uint32 requestVersion, bytes memory request) internal pure returns (Request) {\n        if (requestVersion \u003e REQUEST_SWAP) revert UnknownRequestVersion();\n        if (requestVersion == REQUEST_BASE \u0026\u0026 request.length != REQUEST_BASE_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        if (requestVersion == REQUEST_SWAP \u0026\u0026 request.length != REQUEST_SWAP_LENGTH) {\n            revert IncorrectRequestLength();\n        }\n        // Wrap the BytesArray into Request type\n        return Request.wrap(BytesArray.unwrap(SlicerLib.wrapBytesArray(request)));\n    }\n\n    /// @notice Convenience shortcut for unwrapping a Request into a BytesArray.\n    function unwrap(Request request) internal pure returns (BytesArray) {\n        return BytesArray.wrap(Request.unwrap(request));\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: BASE ═══════════════════════════════════════════════\n\n    /// @notice Extracts the data related to the origin domain.\n    /// @param request          Request to slice\n    /// @return originDomain    Domain of the origin chain\n    /// @return nonce           Nonce of the CCTP message on origin domain\n    /// @return originBurnToken Circle token that was burned on origin domain\n    function originData(Request request)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_ORIGIN_DATA);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get originDomain, we need to shift the data by 256-32=224 bits\n            originDomain := shr(224, data)\n            // To get nonce, we need to shift the data by 256-96=160 bits, then mask the result with 0xFFFFFFFFFFFFFFFF\n            nonce := and(shr(160, data), 0xFFFFFFFFFFFFFFFF)\n            // To get originBurnToken, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            originBurnToken := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        amount = uint256(request.unwrap().sliceBytes32(OFFSET_AMOUNT));\n    }\n\n    /// @notice Extracts the recipient of the tokens on destination domain.\n    /// @param request      Request to slice\n    /// @return Recipient of the tokens on destination domain\n    function recipient(Request request) internal pure returns (address) {\n        return request.unwrap().sliceAddress(OFFSET_RECIPIENT);\n    }\n\n    // ═══════════════════════════════════════════ REQUEST SLICING: SWAP ═══════════════════════════════════════════════\n\n    /// @notice Extracts the swap parameters of the request\n    /// @param request          Request to slice\n    /// @return pool            Liquidity pool for swapping Circle token\n    /// @return tokenIndexFrom  Index of the minted Circle token in the pool\n    /// @return tokenIndexTo    Index of the final token in the pool\n    /// @return deadline        Latest timestamp to execute the swap\n    /// @return minAmountOut    Minimum amount of tokens to receive from the swap\n    function swapParams(Request request)\n        internal\n        pure\n        returns (\n            address pool,\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint80 deadline,\n            uint256 minAmountOut\n        )\n    {\n        bytes32 data = request.unwrap().sliceBytes32(OFFSET_SWAP_PARAMS);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // To get pool, we need to shift the data by 256-160=96 bits\n            pool := shr(96, data)\n            // To get tokenIndexFrom, we need to shift the data by 256-168=88 bits, then mask the result with 0xFF\n            tokenIndexFrom := and(shr(88, data), 0xFF)\n            // To get tokenIndexTo, we need to shift the data by 256-176=80 bits, then mask the result with 0xFF\n            tokenIndexTo := and(shr(80, data), 0xFF)\n            // To get deadline, we need to mask the data with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            deadline := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n        // Read as bytes32 and then cast to uint256\n        minAmountOut = uint256(request.unwrap().sliceBytes32(OFFSET_MIN_AMOUNT_OUT));\n    }\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | Opcode | Opcode + Args | Description    | Stack View                    |\n/// | ---- | ------ | ------------- | -------------- | ----------------------------- |\n/// | 0x00 | 0x60   | 0x6020        | push1 0x20     | 32                            |\n/// | 0x02 | 0x36   | 0x36          | calldatasize   | cds 32                        |\n/// | 0x03 | 0x03   | 0x03          | sub            | (cds-32)                      |\n/// | 0x04 | 0x80   | 0x80          | dup1           | (cds-32) (cds-32)             |\n/// | 0x05 | 0x60   | 0x6020        | push1 0x20     | 32 (cds-32) (cds-32)          |\n/// | 0x07 | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32) (cds-32)         |\n/// | 0x08 | 0x37   | 0x37          | calldatacopy   | (cds-32)                      |\n/// | 0x09 | 0x3d   | 0x3d          | returndatasize | 0 (cds-32)                    |\n/// | 0x0a | 0x3d   | 0x3d          | returndatasize | 0 0 (cds-32)                  |\n/// | 0x0b | 0x3d   | 0x3d          | returndatasize | 0 0 0 (cds-32)                |\n/// | 0x0c | 0x92   | 0x92          | swap3          | (cds-32) 0 0 0                |\n/// | 0x0d | 0x3d   | 0x3d          | returndatasize | 0 (cds-32) 0 0 0              |\n/// | 0x0e | 0x34   | 0x34          | callvalue      | val 0 (cds-32) 0 0 0          |\n/// | 0x0f | 0x3d   | 0x3d          | returndatasize | 0 val 0 (cds-32) 0 0 0        |\n/// | 0x10 | 0x35   | 0x35          | calldataload   | addr val 0 (cds-32) 0 0 0     |\n/// | 0x11 | 0x5a   | 0x5a          | gas            | gas addr val 0 (cds-32) 0 0 0 |\n/// | 0x12 | 0xf1   | 0xf1          | call           | suc 0                         |\n/// | 0x13 | 0x3d   | 0x3d          | returndatasize | rds suc 0                     |\n/// | 0x14 | 0x82   | 0x82          | dup3           | 0 rds suc 0                   |\n/// | 0x15 | 0x80   | 0x80          | dup1           | 0 0 rds suc 0                 |\n/// | 0x16 | 0x3e   | 0x3e          | returndatacopy | suc 0                         |\n/// | 0x17 | 0x90   | 0x90          | swap1          | 0 suc                         |\n/// | 0x18 | 0x3d   | 0x3d          | returndatasize | rds 0 suc                     |\n/// | 0x19 | 0x91   | 0x91          | swap2          | suc 0 rds                     |\n/// | 0x1a | 0x60   | 0x601e        | push1 0x1e     | 0x1e suc 0 rds                |\n/// | 0x1c | 0x57   | 0x57          | jumpi          | 0 rds                         |\n/// | 0x1d | 0xfd   | 0xfd          | revert         |                               |\n/// | 0x1e | 0x5b   | 0x5b          | jumpdest       | 0 rds                         |\n/// | 0x1f | 0xf3   | 0xf3          | return         |                               |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View is shown after the execution of the opcode.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | Opcode | Opcode + Args | Description     | Stack View |\n/// | ---- | ------ | ------------- | --------------- | ---------- |\n/// | 0x00 | 0x7f   | 0x7fXXXX      | push32 bytecode | bytecode   |\n/// | 0x1b | 0x3d   | 0x3d          | returndatasize  | 0 bytecode |\n/// | 0x1c | 0x52   | 0x52          | mstore          |            |\n/// | 0x1d | 0x60   | 0x6020        | push1 0x20      | 32         |\n/// | 0x1f | 0x3d   | 0x3d          | returndatasize  | 0 32       |\n/// | 0x20 | 0xf3   | 0xf3          | return          |            |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPEvents, ISynapseCCTP {\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // TODO: onlyOwner setters for these\n    mapping(uint32 =\u003e bytes32) public remoteSynapseCCTP;\n    mapping(uint256 =\u003e address) internal _remoteTokenIdToLocalToken;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the local token associated with the given remote domain and token.\n    // TODO: add ownerOnly modifier\n    function setLocalToken(uint32 remoteDomain, address remoteToken) external {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        address localToken = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        if (localToken == address(0)) revert LocalCCTPTokenNotFound();\n        _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)] = localToken;\n    }\n\n    /// @notice Sets the remote deployment of SynapseCCTP for the given remote domain.\n    // TODO: add ownerOnly modifier\n    function setRemoteSynapseCCTP(uint32 remoteDomain, address remoteSynapseCCTP_) external {\n        // TODO: add zero checks\n        remoteSynapseCCTP[remoteDomain] = remoteSynapseCCTP_.addressToBytes32();\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint32 destinationDomain,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Pull token from user and update the amount if case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        // Construct the request identifier to be used as salt later.\n        // Origin domain and nonce are already part of the request, so we only need to add the destination domain.\n        bytes32 dstSynapseCCTP = remoteSynapseCCTP[destinationDomain];\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        bytes32 kappa = _kappa(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), kappa)\n        );\n        emit CircleRequestSent(destinationDomain, nonce, burnToken, amount, requestVersion, formattedRequest, kappa);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external {\n        // This will revert if the request version is not supported, or request is not properly formatted.\n        Request request = RequestLib.wrapRequest(requestVersion, formattedRequest);\n        bytes32 kappa = _kappa(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, kappa);\n        (address token, uint256 amount) = _getMintedToken(request);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyFee(token, amount);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        address recipient = request.recipient();\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, requestVersion, request);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, kappa);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _remoteTokenIdToLocalToken[_remoteTokenId(remoteDomain, remoteToken)];\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the bridging fee. Will revert if amount \u003c= fee.\n    function _applyFee(address token, uint256 amount) internal returns (uint256 amountAfterFee, uint256 fee) {\n        // TODO: implement actual fee logic\n        return (amount, 0);\n    }\n\n    /// @dev Approves the token to be transferred to the Circle Bridge.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 kappa\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the kappa has been used before.\n        address forwarder = MinimalForwarderLib.deploy(kappa);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        forwarder.forwardCall(address(messageTransmitter), payload);\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        Request request\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        if (requestVersion == RequestLib.REQUEST_BASE) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        (address pool, uint8 tokenIndexFrom, uint8 tokenIndexTo, uint80 deadline, uint256 minAmountOut) = request\n            .swapParams();\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            return _fullfilBaseRequest(recipient, token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Fulfills a base request by transferring the tokens to the recipient.\n    function _fullfilBaseRequest(\n        address recipient,\n        address token,\n        uint256 amount\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        tokenOut = token;\n        amountOut = amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint80 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Fetches the address and the amount of the minted Circle token.\n    function _getMintedToken(Request request) internal view returns (address token, uint256 amount) {\n        uint32 originDomain;\n        address originBurnToken;\n        (originDomain, , originBurnToken, amount) = request.originData();\n        // Map the remote token to the local token.\n        token = _remoteTokenIdToLocalToken[_remoteTokenId(originDomain, originBurnToken)];\n        if (token == address(0)) revert RemoteCCTPTokenNotSet();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        try IDefaultPool(pool).getToken(tokenIndex) returns (address _token) {\n            token = _token;\n        } catch {\n            // Return 0 on revert\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller.\n    function _destinationCaller(address synapseCCTP, bytes32 kappa) internal pure returns (bytes32) {\n        return synapseCCTP.predictAddress(kappa).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _kappa(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory request\n    ) internal pure returns (bytes32 kappa) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(request);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            kappa := keccak256(0, 64)\n        }\n    }\n\n    /// @dev Packs the domain and the token into a single uint256 value using bitwise operations.\n    function _remoteTokenId(uint32 remoteDomain, address remoteToken) internal pure returns (uint256) {\n        return (uint256(remoteDomain) \u003c\u003c 160) | uint160(remoteToken);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"25779:350:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;25779:350:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"25779:350:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x8bd4b1941497710bf463941f9c5c6b52f85707f0ea20519781cf3fc4b4feca6e\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1e71f3be303374dca6002f1b52d9a618942c9117f16e44817b28c819552876bd\",\"dweb:/ipfs/QmdgQqTPJcwaQMktuxZCZtBQhD8GeNX5xymDVNZ7jbosJb\"]}},\"version\":1}"},"hashes":{}}}